<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TipTap ‚Äî Premium Editor</title>

  <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
  <link
    href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800&family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap"
    rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">

  <style>
    /* Premium Design System */
    :root {
      --plate-bg: #ffffff;
      --plate-border: #e2e8f0;
      --plate-accent: #3b82f6;
      --font-outfit: 'Outfit', sans-serif;
      --font-inter: 'Inter', sans-serif;
      --font-mono: 'JetBrains Mono', monospace;
    }

    body {
      font-family: var(--font-inter);
      background: #f8fafc;
      min-height: 100vh;
      color: #1e293b;
    }

    /* Custom Scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }

    ::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 10px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #94a3b8;
    }

    /* Editor Canvas */
    .ProseMirror {
      outline: none;
      min-height: 600px;
      padding: 60px 80px;
      font-size: 1.05rem;
      line-height: 1.8;
    }

    @media (max-width: 768px) {
      .ProseMirror {
        padding: 40px 24px;
      }
    }

    /* Typography */
    .ProseMirror h1,
    .ProseMirror h2,
    .ProseMirror h3 {
      font-family: var(--font-outfit);
      color: #0f172a;
      line-height: 1.2;
    }

    .ProseMirror h1 {
      font-size: 2.75rem;
      font-weight: 800;
      margin: 2.5rem 0 1.5rem;
    }

    .ProseMirror h2 {
      font-size: 2rem;
      font-weight: 700;
      margin: 2rem 0 1rem;
    }

    .ProseMirror h3 {
      font-size: 1.5rem;
      font-weight: 600;
      margin: 1.5rem 0 0.75rem;
    }

    .ProseMirror p {
      margin-bottom: 1.25rem;
    }

    .ProseMirror a {
      color: var(--plate-accent);
      text-decoration: underline;
      cursor: pointer;
    }

    .global-drag-handle {
      position: absolute;
      width: 24px;
      height: 24px;
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: grab;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.08);
      transition: opacity 0.15s ease, transform 0.15s ease;
      opacity: 0;
      pointer-events: none;
    }

    .global-drag-handle.visible {
      opacity: 1;
      pointer-events: auto;
      transform: translateX(-4px);
    }

    .global-drag-handle::after {
      content: "‚ãÆ‚ãÆ";
      font-size: 14px;
      color: #94a3b8;
    }

    .global-drag-handle:hover {
      background: #f8fafc;
      border-color: #cbd5e1;
    }

    .global-drag-handle:active {
      cursor: grabbing;
    }

    /* Lists */
    .ProseMirror ul,
    .ProseMirror ol {
      padding: 0 1rem;
      margin: 1.25rem 1rem 1.25rem 0.4rem;
    }

    .ProseMirror ul li {
      list-style-type: disc;
    }

    .ProseMirror ol li {
      list-style-type: decimal;
    }

    .ProseMirror li {
      margin-bottom: 0.5rem;
      padding-left: 0.5rem;
    }

    /* Task List */
    ul[data-type="taskList"] {
      list-style: none;
      padding: 0;
    }

    ul[data-type="taskList"] li {
      display: flex;
      gap: 12px;
      margin-bottom: 8px;
      align-items: flex-start;
    }

    ul[data-type="taskList"] li>label {
      flex: 0 0 auto;
      margin-right: 0.5rem;
      user-select: none;
      margin-top: 0.3em;
    }

    ul[data-type="taskList"] li>div {
      flex: 1 1 auto;
    }

    ul[data-type="taskList"] input[type="checkbox"] {
      cursor: pointer;
      width: 1.1em;
      height: 1.1em;
      accent-color: var(--plate-accent);
    }

    ul[data-type="taskList"] li[data-checked="true"]>div {
      text-decoration: line-through;
      color: #94a3b8;
    }

    /* Blockquote */
    .ProseMirror blockquote {
      border-left: 4px solid var(--plate-accent);
      margin: 1.5rem 0;
      padding-left: 1rem;
      font-style: italic;
      color: #475569;
      background: #f8fafc;
      padding: 1rem;
      border-radius: 0 8px 8px 0;
    }

    /* Code Block */
    pre {
      background: #0d1117;
      border-radius: 0.75rem;
      color: #c9d1d9;
      font-family: var(--font-mono);
      padding: 2.5rem 1.5rem 1.5rem;
      margin: 1.5rem 0;
      position: relative;
      overflow-x: auto;
    }

    pre code {
      background: none;
      color: inherit;
      font-size: 0.85rem;
      padding: 0;
    }

    .hljs-comment,
    .hljs-quote {
      color: #8b949e;
    }

    .hljs-variable,
    .hljs-template-variable,
    .hljs-tag,
    .hljs-name,
    .hljs-selector-id,
    .hljs-selector-class,
    .hljs-regexp,
    .hljs-deletion {
      color: #d2a8ff;
    }

    .hljs-number,
    .hljs-built_in,
    .hljs-builtin-name,
    .hljs-literal,
    .hljs-type,
    .hljs-params,
    .hljs-meta,
    .hljs-link {
      color: #79c0ff;
    }

    .hljs-section,
    .hljs-title {
      color: #d2a8ff;
    }

    .hljs-keyword,
    .hljs-selector-tag {
      color: #ff7b72;
    }

    /* Language Selecror */
    .language-selector {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      background: #21262d;
      color: #c9d1d9;
      border: 1px solid #30363d;
      border-radius: 4px;
      font-size: 0.75rem;
      padding: 2px 6px;
      z-index: 10;
      opacity: 0.5;
      transition: opacity 0.2s;
      cursor: pointer;
    }

    .code-block-wrapper:hover .language-selector {
      opacity: 1;
    }

    /* Tables */
    .tableWrapper {
      margin: 2rem 0;
      overflow-x: auto;
    }

    table {
      border-collapse: collapse;
      table-layout: fixed;
      width: 100%;
      margin: 0;
      overflow: hidden;
      border-radius: 8px;
    }

    td,
    th {
      min-width: 1em;
      border: 1px solid #cbd5e1;
      padding: 10px 12px;
      vertical-align: top;
      box-sizing: border-box;
      position: relative;
    }

    th {
      font-weight: 600;
      text-align: left;
      background-color: #f1f5f9;
    }

    .selectedCell:after {
      z-index: 2;
      position: absolute;
      content: "";
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      background: rgba(59, 130, 246, 0.15);
      pointer-events: none;
    }

    /* Images & Video */
    img {
      max-width: 100%;
      height: auto;
      border-radius: 12px;
      margin: 1.5rem 0;
      display: block;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
    }

    iframe {
      width: 100%;
      aspect-ratio: 16/9;
      border-radius: 12px;
      margin: 1.5rem 0;
      border: none;
      background: #000;
    }

    /* Callouts */
    .callout {
      padding: 1.25rem;
      border-radius: 0.75rem;
      margin: 1.5rem 0;
      border: 1px solid transparent;
      display: flex;
      gap: 1rem;
      align-items: flex-start;
    }

    .callout-info {
      background: #eff6ff;
      border-color: #bfdbfe;
      color: #1e40af;
    }

    .callout-success {
      background: #f0fdf4;
      border-color: #bbf7d0;
      color: #166534;
    }

    .callout-warning {
      background: #fffbeb;
      border-color: #fde68a;
      color: #92400e;
    }

    .callout-error {
      background: #fef2f2;
      border-color: #fecaca;
      color: #991b1b;
    }

    .callout div p {
      margin: 0;
    }

    .callout-icon {
      font-size: 1.25rem;
      line-height: 1;
      user-select: none;
    }

    /* Page Break */
    .page-break {
      margin: 2rem 0;
      border: none;
      border-top: 2px dashed #cbd5e1;
      position: relative;
      height: 1px;
    }

    .page-break::after {
      content: "Page Break";
      position: absolute;
      top: -10px;
      left: 50%;
      transform: translateX(-50%);
      background: #f8fafc;
      padding: 0 10px;
      color: #94a3b8;
      font-size: 0.75rem;
      font-weight: 500;
      text-transform: uppercase;
    }

    /* Math Block Improved */
    .math-block-container {
      margin: 1.5rem 0;
      border-radius: 0.5rem;
      border: 1px solid transparent;
      transition: all 0.2s;
    }

    .math-block-container:hover {
      border-color: #e2e8f0;
    }

    .math-block-container.is-editing {
      border-color: var(--plate-accent);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
      background: #fff;
    }

    .math-preview {
      padding: 1rem;
      text-align: center;
      cursor: pointer;
      min-height: 2.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f8fafc;
      border-radius: 0.5rem;
    }

    .math-preview:hover {
      background: #f1f5f9;
    }

    .math-input {
      width: 100%;
      padding: 0.75rem;
      font-family: var(--font-mono);
      font-size: 0.9rem;
      background: #1e293b;
      color: #e2e8f0;
      border: none;
      border-radius: 0 0 0.5rem 0.5rem;
      outline: none;
      resize: vertical;
      display: none;
      /* Hidden by default */
    }

    .is-editing .math-preview {
      border-radius: 0.5rem 0.5rem 0 0;
      border-bottom: 1px solid #e2e8f0;
      background: #fff;
    }

    .is-editing .math-input {
      display: block;
    }

    .katex-display {
      margin: 0 !important;
    }

    /* Slash Menu */
    .slash-popup {
      background: white;
      border: 1px solid #e2e8f0;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
      border-radius: 12px;
      width: 300px;
      max-height: 360px;
      overflow-y: auto;
      padding: 0.5rem;
      z-index: 50;
      display: none;
      /* hidden initially */
    }

    .slash-group {
      margin-bottom: 0.5rem;
    }

    .slash-group-title {
      font-size: 0.75rem;
      font-weight: 600;
      color: #94a3b8;
      padding: 0.5rem 0.75rem 0.25rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .slash-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      color: #334155;
      font-size: 0.9rem;
      transition: all 0.15s;
    }

    .slash-item:hover {
      background: #f8fafc;
    }

    .slash-item.is-selected {
      background: #eff6ff;
      color: #2563eb;
    }

    .slash-item-icon {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f1f5f9;
      border-radius: 4px;
      font-size: 0.8rem;
      color: #64748b;
    }

    .slash-item.is-selected .slash-item-icon {
      background: #dbeafe;
      color: #2563eb;
    }

    .slash-item-content {
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .slash-item-title {
      font-weight: 500;
      line-height: 1.2;
    }

    .slash-item-desc {
      font-size: 0.75rem;
      color: #94a3b8;
      line-height: 1.2;
      margin-top: 2px;
    }

    /* Placeholders */
    .is-empty::before {
      content: attr(data-placeholder);
      float: left;
      color: #adb5bd;
      pointer-events: none;
      height: 0;
    }

    /* Modal System */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
    }

    .modal-overlay.active {
      opacity: 1;
      pointer-events: all;
    }

    .modal-card {
      background: white;
      width: 100%;
      max-width: 420px;
      padding: 24px;
      border-radius: 16px;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      transform: scale(0.95);
      transition: transform 0.2s;
    }

    .modal-overlay.active .modal-card {
      transform: scale(1);
    }

    .modal-title {
      font-size: 1.25rem;
      font-weight: 700;
      margin-bottom: 1rem;
      color: #0f172a;
    }

    .modal-input {
      width: 100%;
      padding: 10px 14px;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      margin-bottom: 1.5rem;
      outline: none;
      transition: border-color 0.2s;
    }

    .modal-input:focus {
      border-color: var(--plate-accent);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
    }

    .btn {
      padding: 8px 16px;
      border-radius: 8px;
      font-weight: 500;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-secondary {
      background: #f1f5f9;
      color: #475569;
    }

    .btn-secondary:hover {
      background: #e2e8f0;
    }

    .btn-primary {
      background: var(--plate-accent);
      color: white;
    }

    .btn-primary:hover {
      background: #2563eb;
    }

    /* Bubble Menu (Tables) */
    .bubble-menu {
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      display: flex;
      padding: 4px;
      gap: 4px;
      position: absolute;
      z-index: 20;
    }

    .bubble-menu.hidden {
      display: none;
    }

    .bubble-btn {
      background: transparent;
      border: none;
      color: #64748b;
      padding: 6px;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
    }

    .bubble-btn:hover {
      background: #f1f5f9;
      color: #0f172a;
    }

    /* Resize Handles */
    .node-image,
    .node-video {
      display: block;
      /* position: relative; set by style */
      user-select: none;
      line-height: 0;
      /* Remove bottom gap */
    }

    .node-image img,
    .node-video video {
      display: block;
      width: 100%;
      height: auto;
    }

    .resize-handle {
      position: absolute;
      right: -6px;
      bottom: -6px;
      width: 12px;
      height: 12px;
      background: #3b82f6;
      border: 2px solid white;
      border-radius: 50%;
      cursor: nwse-resize;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 10;
    }

    .ProseMirror-selectednode .resize-handle,
    .node-container:hover .resize-handle {
      opacity: 1;
    }

    /* File Attachment */
    .file-attachment {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      margin: 1.5rem 0;
      text-decoration: none;
      transition: all 0.2s;
      width: fit-content;
      cursor: pointer;
    }

    .file-attachment:hover {
      background: #f1f5f9;
      border-color: #cbd5e1;
    }

    .file-icon {
      font-size: 1.5rem;
    }

    .file-info {
      display: flex;
      flex-direction: column;
    }

    .file-name {
      font-weight: 500;
      color: #334155;
      font-size: 0.95rem;
    }

    .file-size {
      font-size: 0.75rem;
      color: #64748b;
    }
  </style>
</head>

<body class="flex flex-col items-center py-12">

  <div class="w-full max-w-5xl lg:px-8">
    <!-- Header -->
    <div class="mb-10 px-6 lg:px-0 text-center">
      <h1 class="text-4xl font-extrabold tracking-tight text-slate-900 mb-2 font-[Outfit]">Premium Editor</h1>
      <p class="text-slate-500">
        Type <code class="bg-white border border-slate-200 px-1.5 py-0.5 rounded text-sm mx-1 shadow-sm">/</code> to
        browse commands
      </p>
    </div>

    <!-- Editor Container -->
    <div class="bg-white border border-slate-200 rounded-2xl shadow-xl overflow-hidden min-h-[80vh] mx-4 relative">
      <div id="editor"></div>
    </div>

    <div
      class="mt-8 bg-slate-100 rounded-lg p-4 mx-4 text-xs font-mono text-slate-600 overflow-auto max-h-96 w-full max-w-5xl">
      <div class="font-bold mb-2">Debug JSON:</div>
      <pre id="debug-json">{}</pre>
    </div>
  </div>

  <!-- Table Controls (Bubble Menu Container) -->
  <div id="table-bubble-menu" class="hidden">
    <!-- Buttons injected by JS -->
  </div>

  <!-- AI Bubble Menu -->
  <div id="ai-bubble-menu"
    class="hidden flex items-center gap-1 bg-white border border-slate-200 rounded-lg shadow-lg p-1">
    <button data-action="improve"
      class="ai-btn flex items-center gap-2 px-2 py-1 text-sm text-slate-600 hover:bg-slate-100 rounded">
      <span>‚ú®</span> Improve
    </button>
    <button data-action="summarize"
      class="ai-btn flex items-center gap-2 px-2 py-1 text-sm text-slate-600 hover:bg-slate-100 rounded">
      <span>üìù</span> Summarize
    </button>
    <button data-action="explain"
      class="ai-btn flex items-center gap-2 px-2 py-1 text-sm text-slate-600 hover:bg-slate-100 rounded">
      <span>ü§î</span> Explain
    </button>
    <button data-action="continue"
      class="ai-btn flex items-center gap-2 px-2 py-1 text-sm text-slate-600 hover:bg-slate-100 rounded">
      <span>‚û°Ô∏è</span> Continue
    </button>
    <div id="ai-loader" class="hidden ml-2">
      <div class="animate-spin h-4 w-4 border-2 border-blue-500 border-t-transparent rounded-full"></div>
    </div>
  </div>

  <!-- Universal Modal -->
  <div id="ui-modal" class="modal-overlay">
    <div class="modal-card">
      <h3 id="modal-title" class="modal-title">Insert Content</h3>
      <input type="text" id="modal-input" class="modal-input" placeholder="https://..." />
      <div class="modal-actions">
        <button id="modal-cancel" class="btn btn-secondary">Cancel</button>
        <button id="modal-confirm" class="btn btn-primary">Insert</button>
      </div>
    </div>
  </div>
  </div>

  <!-- Loading Overlay -->
  <div id="loading-overlay" class="modal-overlay" style="z-index: 200;">
    <div class="bg-white p-6 rounded-lg shadow-xl flex flex-col items-center">
      <div class="animate-spin rounded-full h-10 w-10 border-b-2 border-blue-600 mb-4"></div>
      <p class="text-slate-600 font-medium">Uploading...</p>
    </div>
  </div>

  <!-- AI Preview Overlay -->
  <div id="ai-preview-overlay"
    class="hidden fixed bottom-10 left-1/2 transform -translate-x-1/2 bg-white border border-slate-200 shadow-2xl rounded-xl w-[600px] max-w-[90vw] z-50 flex flex-col overflow-hidden">
    <div class="bg-slate-50 px-4 py-2 border-b border-slate-100 flex justify-between items-center">
      <span class="text-xs font-semibold text-slate-500 uppercase tracking-wider">AI Preview</span>
      <div class="flex gap-2">
        <span id="ai-status" class="text-xs text-blue-500 animate-pulse">Generative...</span>
      </div>
    </div>
    <div id="ai-preview-content" class="p-6 max-h-[60vh] overflow-y-auto prose prose-sm">
      <!-- AI Content Stream -->
    </div>
    <div class="p-3 bg-slate-50 border-t border-slate-100 flex justify-end gap-2">
      <button id="ai-reject"
        class="px-3 py-1.5 text-sm text-slate-600 hover:bg-slate-200 rounded-md transition-colors">Discard</button>
      <button id="ai-accept"
        class="px-3 py-1.5 text-sm bg-blue-600 text-white hover:bg-blue-700 rounded-md shadow-sm transition-colors">Accept</button>
    </div>
  </div>

  <script type="module">
    import { Editor, Node, mergeAttributes, Extension, InputRule, wrappingInputRule } from 'https://esm.sh/@tiptap/core@2.11.5?bundle';

    import Document from 'https://esm.sh/@tiptap/extension-document@2.11.5?bundle';
    import Paragraph from 'https://esm.sh/@tiptap/extension-paragraph@2.11.5?bundle';
    import Text from 'https://esm.sh/@tiptap/extension-text@2.11.5?bundle';
    import Blockquote from 'https://esm.sh/@tiptap/extension-blockquote@2.11.5?bundle';
    import BulletList from 'https://esm.sh/@tiptap/extension-bullet-list@2.11.5?bundle';
    import OrderedList from 'https://esm.sh/@tiptap/extension-ordered-list@2.11.5?bundle';
    import ListItem from 'https://esm.sh/@tiptap/extension-list-item@2.11.5?bundle';
    import HardBreak from 'https://esm.sh/@tiptap/extension-hard-break@2.11.5?bundle';
    import HorizontalRule from 'https://esm.sh/@tiptap/extension-horizontal-rule@2.11.5?bundle';
    import Heading from 'https://esm.sh/@tiptap/extension-heading@2.11.5?bundle';
    import Bold from 'https://esm.sh/@tiptap/extension-bold@2.11.5?bundle';
    import Code from 'https://esm.sh/@tiptap/extension-code@2.11.5?bundle';
    import Italic from 'https://esm.sh/@tiptap/extension-italic@2.11.5?bundle';
    import Strike from 'https://esm.sh/@tiptap/extension-strike@2.11.5?bundle';
    import Dropcursor from 'https://esm.sh/@tiptap/extension-dropcursor@2.11.5?bundle';
    import Gapcursor from 'https://esm.sh/@tiptap/extension-gapcursor@2.11.5?bundle';
    import History from 'https://esm.sh/@tiptap/extension-history@2.11.5?bundle';
    import Placeholder from 'https://esm.sh/@tiptap/extension-placeholder@2.11.5?bundle';
    import TaskList from 'https://esm.sh/@tiptap/extension-task-list@2.11.5?bundle';
    import TaskItem from 'https://esm.sh/@tiptap/extension-task-item@2.11.5?bundle';
    import Link from 'https://esm.sh/@tiptap/extension-link@2.11.5?bundle';
    import Image from 'https://esm.sh/@tiptap/extension-image@2.11.5?bundle';
    import Table from 'https://esm.sh/@tiptap/extension-table@2.11.5?bundle';
    import TableRow from 'https://esm.sh/@tiptap/extension-table-row@2.11.5?bundle';
    import TableCell from 'https://esm.sh/@tiptap/extension-table-cell@2.11.5?bundle';
    import TableHeader from 'https://esm.sh/@tiptap/extension-table-header@2.11.5?bundle';
    import Youtube from 'https://esm.sh/@tiptap/extension-youtube@2.11.5?bundle';
    import { BubbleMenu } from 'https://esm.sh/@tiptap/extension-bubble-menu@2.11.5?bundle';
    import CodeBlockLowlight from 'https://esm.sh/@tiptap/extension-code-block-lowlight@2.11.5?bundle';
    import { common, createLowlight } from 'https://esm.sh/lowlight?bundle';
    import katex from 'https://esm.sh/katex';
    import Suggestion from 'https://esm.sh/@tiptap/suggestion@2.11.5?bundle';
    import { Markdown } from 'https://esm.sh/tiptap-markdown@0.8.10?bundle';
    import { Plugin, PluginKey, NodeSelection, TextSelection } from 'https://esm.sh/prosemirror-state?bundle';
    // serializeForClipboard is not exported by default in some bundles. 
    // We can use a simpler approach for the drag handle: just selecting the node is often enough for Tiptap/ProseMirror to handle the drag if we let the event bubble?
    // Actually, we need to manually set the drag data if we initiate it from an external element.
    // But since we can't easily get serializeForClipboard, let's try a different strategy:
    // Select the node, and rely on standard behavior if possible, or construct basic HTML.
    import { DOMSerializer } from 'https://esm.sh/prosemirror-model?bundle';

    /* --- Constants --- */
    const GEMINI_API_KEY = ''; // Replace with actual key or env var if possible
    const GEMINI_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;


    // Initialize Lowlight (Syntax Highlighting)
    const lowlight = createLowlight(common);

    /* --- Custom UI Helpers --- */
    const Modal = {
      overlay: document.getElementById('ui-modal'),
      title: document.getElementById('modal-title'),
      input: document.getElementById('modal-input'),
      confirm: document.getElementById('modal-confirm'),
      cancel: document.getElementById('modal-cancel'),
      resolve: null,

      open(title, placeholder = 'Enter URL...') {
        this.title.textContent = title;
        this.input.placeholder = placeholder;
        this.input.value = '';
        this.overlay.classList.add('active');
        this.input.focus();

        return new Promise((resolve) => {
          this.resolve = resolve;
        });
      },

      close() {
        this.overlay.classList.remove('active');
        this.resolve = null;
      }
    };

    Modal.confirm.onclick = () => {
      if (Modal.resolve) Modal.resolve(Modal.input.value);
      Modal.close();
    };

    Modal.cancel.onclick = () => {
      if (Modal.resolve) Modal.resolve(null);
      Modal.close();
    };

    Modal.input.onkeydown = (e) => {
      if (e.key === 'Enter') Modal.confirm.click();
      if (e.key === 'Escape') Modal.cancel.click();
    };

    /* --- File Upload Helper --- */
    const triggerFileUpload = (accept) => {
      return new Promise((resolve) => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = accept;
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (file) {
            const loading = document.getElementById('loading-overlay');
            loading.classList.add('active'); // Show loading

            // Use URL.createObjectURL instead of FileReader for performance.
            // Reading large files (videos) as Base64 strings (readAsDataURL) freezes the main thread.
            // Blob URLs are instant and lightweight.
            const objectUrl = URL.createObjectURL(file);

            // Simulate a small network delay for realism/UX
            setTimeout(() => {
              loading.classList.remove('active'); // Hide loading
              resolve({
                src: objectUrl,
                name: file.name,
                size: file.size,
                type: file.type
              });
            }, 600);
          } else {
            resolve(null);
          }
        };
        input.click();
      });
    };

    /* --- Resizable Node View Factory --- */
    const createResizableNodeView = (type) => {
      return ({ node, editor, getPos }) => {
        const container = document.createElement('div');
        container.classList.add('node-container'); // Helper class for hover
        container.style.position = 'relative';
        container.style.display = 'inline-block';
        container.style.maxWidth = '100%';
        container.style.margin = '1.5rem 0';
        container.style.lineHeight = '0';

        // Initial width
        container.style.width = node.attrs.width || '100%';

        const media = document.createElement(type === 'video' ? 'video' : 'img');
        if (type === 'video') {
          media.controls = true;
          // Prevent drag on video controls from conflicting?
        }
        media.style.borderRadius = '12px';
        media.src = node.attrs.src;
        media.style.width = '100%';
        media.style.height = 'auto';
        media.style.display = 'block';
        // media.draggable = false; // Let container handle selection

        const handle = document.createElement('div');
        handle.className = 'resize-handle';

        // Drag logic
        handle.addEventListener('mousedown', (e) => {
          e.preventDefault();
          e.stopPropagation(); // Stop editor selection
          const startX = e.clientX;
          const startWidth = container.offsetWidth;

          const onMouseMove = (e) => {
            const currentX = e.clientX;
            const diffX = currentX - startX;
            const newWidth = Math.max(100, startWidth + diffX);
            container.style.width = `${newWidth}px`;
          };

          const onMouseUp = () => {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            if (typeof getPos === 'function') {
              const pos = getPos();
              if (pos !== undefined && pos !== null) {
                editor.commands.updateAttributes(pos, { width: container.style.width });
              }
            }
          };

          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        });

        container.append(media, handle);

        return {
          dom: container,
          update: (updatedNode) => {
            if (updatedNode.type.name !== (type === 'video' ? 'video' : 'image')) return false;
            if (updatedNode.attrs.src !== node.attrs.src) media.src = updatedNode.attrs.src;
            if (updatedNode.attrs.width !== node.attrs.width) container.style.width = updatedNode.attrs.width;
            node = updatedNode;
            return true;
          },
          selectNode: () => {
            container.classList.add('ProseMirror-selectednode');
            media.style.outline = '3px solid #3b82f6';
            media.style.outlineOffset = '2px';
          },
          deselectNode: () => {
            container.classList.remove('ProseMirror-selectednode');
            media.style.outline = 'none';
          }
        };
      }
    }

    // 0. Video Node (Local)
    const Video = Node.create({
      name: 'video',
      group: 'block',
      selectable: true,
      draggable: true,
      atom: true,

      addAttributes() {
        return {
          src: { default: null },
          width: { default: '100%' }
        }
      },

      parseHTML() {
        return [{ tag: 'video' }]
      },

      renderHTML({ HTMLAttributes }) {
        return ['video', mergeAttributes(HTMLAttributes, { controls: 'true', style: `width: ${HTMLAttributes.width}` })]
      },

      addNodeView() {
        return createResizableNodeView('video');
      }
    });

    // Custom Image Node for Resizing
    const CustomImage = Image.extend({
      addAttributes() {
        // Safe fallback for parent attributes
        const parentAttrs = this.parent ? this.parent() : {};
        return {
          ...parentAttrs,
          width: { default: '100%' }
        }
      },
      addNodeView() {
        return createResizableNodeView('image');
      }
    });

    // 0. File Attachment Node
    const FileAttachment = Node.create({
      name: 'fileAttachment',
      group: 'block',
      atom: true,

      addAttributes() {
        return {
          src: { default: null },
          name: { default: 'file' },
          size: { default: 0 }
        }
      },

      parseHTML() {
        return [{ tag: 'div[data-type="file-attachment"]' }]
      },

      renderHTML({ HTMLAttributes }) {
        return ['div', mergeAttributes(HTMLAttributes, { 'data-type': 'file-attachment' })]
      },

      addNodeView() {
        return ({ node }) => {
          const dom = document.createElement('a');
          dom.className = 'file-attachment';
          dom.href = node.attrs.src;
          dom.download = node.attrs.name;
          dom.contentEditable = 'false';

          const sizeKB = (node.attrs.size / 1024).toFixed(1);

          dom.innerHTML = `
            <div class="file-icon">üìé</div>
            <div class="file-info">
              <span class="file-name">${node.attrs.name}</span>
              <span class="file-size">${sizeKB} KB</span>
            </div>
          `;

          return { dom };
        }
      }
    });

    // 1. Math Block
    const MathBlock = Node.create({
      name: 'mathBlock',
      group: 'block',
      atom: true,

      addAttributes() {
        return {
          text: {
            default: 'E = mc^2',
            parseHTML: element => element.getAttribute('data-text'),
            renderHTML: attributes => ({ 'data-text': attributes.text }),
          }
        }
      },

      parseHTML() {
        return [{
          tag: 'div[data-type="math-block"]',
          getAttrs: dom => ({ text: dom.getAttribute('data-text') })
        }]
      },

      renderHTML({ HTMLAttributes }) {
        return ['div', mergeAttributes(HTMLAttributes, { 'data-type': 'math-block' })]
      },

      addStorage() {
        return {
          markdown: {
            serialize: (state, node) => {
              state.write(`$$\n${node.attrs.text}\n$$`);
              state.closeBlock(node);
            }
          }
        }
      },

      addInputRules() {
        return [
          new InputRule({
            find: /^\$\$\s$/,
            handler: ({ state, range }) => {
              const { tr } = state;
              tr.replaceWith(range.from, range.to, this.type.create());
            }
          }),
        ]
      },

      addNodeView() {
        return ({ node, getPos, editor }) => {
          const container = document.createElement('div');
          container.classList.add('math-block-container');

          const preview = document.createElement('div');
          preview.classList.add('math-preview');
          preview.title = 'Click to edit equation';

          const input = document.createElement('textarea');
          input.classList.add('math-input');
          input.value = node.attrs.text;
          input.placeholder = 'Type LaTeX equation (e.g. E = mc^2)';

          const renderMath = (text) => {
            preview.innerHTML = '';
            if (!text || text.trim() === '') {
              preview.textContent = 'Empty equation';
              preview.style.color = '#94a3b8';
              return;
            }
            try {
              katex.render(text, preview, {
                throwOnError: false,
                displayMode: true
              });
              preview.style.color = 'inherit';
            } catch (e) {
              preview.textContent = e.message;
              preview.style.color = '#ef4444';
            }
          };

          // Initial Render
          renderMath(node.attrs.text);

          // Interaction Logic
          let isEditing = false;

          const toggleEdit = (active) => {
            if (isEditing === active) return; // Debounce duplicate state changes
            isEditing = active;

            if (active) {
              container.classList.add('is-editing');
              // Small delay to ensure display:block applied before focus
              setTimeout(() => {
                input.focus();
              }, 10);
            } else {
              container.classList.remove('is-editing');
              // Save changes if dirty
              if (input.value !== node.attrs.text) {
                if (typeof getPos === 'function') {
                  const pos = getPos();
                  if (pos !== undefined && pos !== null) {
                    editor.chain().focus().command(({ tr }) => {
                      return tr.setNodeAttribute(pos, 'text', input.value);
                    }).run();
                  }
                }
              }
            }
          };

          preview.addEventListener('click', (e) => {
            e.preventDefault();
            toggleEdit(true);
          });

          input.addEventListener('input', (e) => {
            // Just update preview locally, don't trigger transaction yet
            renderMath(e.target.value);
          });

          input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              toggleEdit(false);
              editor.commands.focus(); // Return focus to editor
            }
          });

          // Handle blur - checks if focus moved outside the component
          input.addEventListener('blur', (e) => {
            // We use a timeout to allow clicks on other parts of UI to process first if needed
            // But simpler: just close.
            toggleEdit(false);
          });

          container.append(preview, input);

          return {
            dom: container,
            // Prevent ProtonMirror from re-rendering the node when we type in the textarea
            ignoreMutation: (mutation) => {
              // We handle our own mutations (textarea input)
              return true;
            },
            // Stop events from bubbling up to the editor to prevent unwanted side effects
            stopEvent: (event) => {
              // Allow default behavior for the textarea (keyboard interaction, etc.)
              if (event.target === input) {
                // For keydown, we want to stop propagation so Tiptap doesn't handle Enter/Backspace etc.
                // But for 'input', maybe not?
                // Generally returning true safely isolates the input.
                return true;
              }
              return false;
            },
            update: (updatedNode) => {
              if (updatedNode.type.name !== 'mathBlock') return false;
              // Sync local state if external update happened (e.g. Undo/Redo)
              if (updatedNode.attrs.text !== node.attrs.text) {
                node = updatedNode;
                input.value = node.attrs.text;
                renderMath(node.attrs.text);
              }
              return true;
            },
            selectNode: () => {
              container.classList.add('ProseMirror-selectednode');
            },
            deselectNode: () => {
              container.classList.remove('ProseMirror-selectednode');
              toggleEdit(false);
            }
          };
        }
      }
    });

    // 2. Callout
    const Callout = Node.create({
      name: 'callout',
      group: 'block',
      content: 'block+',
      draggable: true,
      addAttributes() {
        return {
          type: { default: 'info' }
        }
      },
      addInputRules() {
        return [
          wrappingInputRule({ find: /^! $/, type: this.type }),
          wrappingInputRule({ find: /^!info $/, type: this.type, getAttributes: () => ({ type: 'info' }) }),
          wrappingInputRule({ find: /^!success $/, type: this.type, getAttributes: () => ({ type: 'success' }) }),
          wrappingInputRule({ find: /^!warning $/, type: this.type, getAttributes: () => ({ type: 'warning' }) }),
          wrappingInputRule({ find: /^!error $/, type: this.type, getAttributes: () => ({ type: 'error' }) }),
        ]
      },
      addKeyboardShortcuts() {
        return {
          'Enter': ({ editor }) => {
            if (!editor.isActive('callout')) return false;
            const { selection } = editor.state;
            if (selection.$from.parent.content.size === 0) return editor.commands.lift('callout');
            return false;
          },
          'Backspace': ({ editor }) => {
            if (!editor.isActive('callout')) return false;
            const { selection } = editor.state;
            if (selection.empty && selection.$from.parentOffset === 0 && selection.$from.parent.content.size === 0) {
              return editor.commands.lift('callout');
            }
            return false;
          },
        }
      },
      addNodeView() {
        return ({ node, editor, getPos }) => {
          const dom = document.createElement('div');
          dom.classList.add('callout', `callout-${node.attrs.type}`);
          dom.style.position = 'relative';

          const icon = document.createElement('span');
          icon.className = 'callout-icon';
          icon.contentEditable = 'false';
          const getIcon = (t) => {
            if (t === 'success') return '‚úÖ';
            if (t === 'warning') return '‚ö†Ô∏è';
            if (t === 'error') return '‚õî';
            return 'üí°';
          };
          icon.innerText = getIcon(node.attrs.type);

          const content = document.createElement('div');
          content.className = 'callout-content';
          content.style.flex = '1';

          // Type Selector (Premium Feature)
          const select = document.createElement('select');
          select.className = 'callout-type-select';
          select.style.cssText = `
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.1);
            background: rgba(255,255,255,0.8);
            opacity: 0;
            transition: opacity 0.2s;
            cursor: pointer;
            outline: none;
            color: #475569;
            font-weight: 600;
          `;
          ['info', 'success', 'warning', 'error'].forEach(t => {
            const opt = document.createElement('option');
            opt.value = t;
            opt.innerText = t.charAt(0).toUpperCase() + t.slice(1);
            if (node.attrs.type === t) opt.selected = true;
            select.appendChild(opt);
          });

          dom.onmouseenter = () => select.style.opacity = '1';
          dom.onmouseleave = () => select.style.opacity = '0';

          select.onchange = (e) => {
            if (typeof getPos === 'function') {
              editor.commands.updateAttributes(getPos(), { type: e.target.value });
            }
          };

          dom.append(icon, content, select);

          return {
            dom,
            contentDOM: content,
            update: (updatedNode) => {
              if (updatedNode.type.name !== 'callout') return false;
              if (updatedNode.attrs.type !== node.attrs.type) {
                dom.classList.remove(`callout-${node.attrs.type}`);
                dom.classList.add(`callout-${updatedNode.attrs.type}`);
                icon.innerText = getIcon(updatedNode.attrs.type);
                select.value = updatedNode.attrs.type;
              }
              node = updatedNode;
              return true;
            }
          };
        }
      },
      addStorage() {
        return {
          markdown: {
            serialize: (state, node) => {
              state.write(`> [!${node.attrs.type || 'info'}]\n`);
              state.renderContent(node);
            }
          }
        }
      },
      parseHTML() {
        return [{ tag: 'div[data-type="callout"]', contentElement: '.callout-content' }]
      },
      renderHTML({ HTMLAttributes }) {
        return ['div', mergeAttributes(HTMLAttributes, { class: `callout callout-${HTMLAttributes.type}`, 'data-type': 'callout' }),
          ['div', { class: 'callout-content' }, 0]
        ]
      }
    });

    // 3. Page Break
    const PageBreak = Node.create({
      name: 'pageBreak',
      group: 'block',
      atom: true,
      parseHTML() { return [{ tag: 'div.page-break' }] },
      renderHTML({ HTMLAttributes }) {
        return ['div', mergeAttributes(HTMLAttributes, { class: 'page-break' })]
      }
    });


    // 5. Custom Code Block with Selector
    const CustomCodeBlock = CodeBlockLowlight.extend({
      addNodeView() {
        return ({ node, editor, getPos, extension }) => {
          const dom = document.createElement('div');
          dom.style.position = 'relative';
          dom.className = 'code-block-wrapper';

          const select = document.createElement('select');
          select.className = 'language-selector';
          select.contentEditable = 'false';

          // Common languages
          const langs = ['javascript', 'css', 'html', 'python', 'java', 'cpp', 'typescript', 'json', 'bash', 'go', 'rust'];

          langs.forEach(lang => {
            const option = document.createElement('option');
            option.value = lang;
            option.innerText = lang;
            if (lang === node.attrs.language) option.selected = true;
            select.appendChild(option);
          });

          select.addEventListener('change', (e) => {
            if (typeof getPos === 'function') {
              editor.commands.updateAttributes(getPos(), { language: e.target.value });
            }
          });

          const pre = document.createElement('pre');
          const code = document.createElement('code');

          pre.append(code);
          dom.append(select, pre);

          return {
            dom,
            contentDOM: code,
            update: (updatedNode) => {
              if (updatedNode.type.name !== this.name) return false;
              if (updatedNode.attrs.language !== node.attrs.language) {
                select.value = updatedNode.attrs.language;
              }
              return true;
            }
          };
        }
      }
    });

    // 6. MCQ Node
    const Mcq = Node.create({
      name: 'mcq',
      group: 'block',
      atom: true,
      draggable: true,
      selectable: true,

      addAttributes() {
        return {
          question: {
            default: '',
          },
          options: {
            default: [
              { id: '1', text: 'Option 1', isCorrect: false },
              { id: '2', text: 'Option 2', isCorrect: false },
            ],
          }
        }
      },
      addStorage() {
        return {
          markdown: {
            serialize: (state, node) => {
              state.write(`? ${node.attrs.question}\n`);
              node.attrs.options.forEach(opt => {
                state.write(`${opt.isCorrect ? '(x)' : '( )'} ${opt.text}\n`);
              });
              state.closeBlock(node);
            }
          }
        }
      },
      addInputRules() {
        return [
          new InputRule({
            find: /^\? $/,
            handler: ({ state, range }) => {
              const { tr } = state;
              tr.replaceWith(range.from, range.to, this.type.create());
            }
          }),
        ]
      },

      parseHTML() {
        return [
          {
            tag: 'div[data-type="mcq"]',
          },
        ]
      },

      renderHTML({ HTMLAttributes }) {
        return ['div', mergeAttributes(HTMLAttributes, { 'data-type': 'mcq' })]
      },

      addNodeView() {
        return ({ node, getPos, editor }) => {
          // 1. Container
          const dom = document.createElement('div');
          dom.classList.add('mcq-node');
          dom.style.cssText = `
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            padding: 1.5rem;
            background: #fff;
            margin: 2rem 0;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transition: border-color 0.2s, box-shadow 0.2s;
            position: relative;
          `;

          // 2. Helper for Safe Updates
          const updateAttrs = (attrs) => {
            if (typeof getPos === 'function') {
              const pos = getPos();
              if (pos !== undefined && pos !== null) {
                editor.view.dispatch(
                  editor.state.tr.setNodeMarkup(pos, undefined, {
                    ...node.attrs,
                    ...attrs,
                  })
                );
              }
            }
          };

          // 3. Question Input
          const questionInput = document.createElement('input');
          questionInput.type = 'text';
          questionInput.placeholder = 'Enter your question...';
          questionInput.value = node.attrs.question;
          questionInput.style.cssText = `
            width: 100%;
            font-family: inherit;
            font-size: 1.125rem;
            font-weight: 600;
            color: #1e293b;
            border: none;
            border-bottom: 2px solid #e2e8f0;
            padding: 0.5rem 0;
            margin-bottom: 1.5rem;
            background: transparent;
            outline: none;
            transition: border-color 0.2s;
          `;

          questionInput.oninput = (e) => updateAttrs({ question: e.target.value });
          questionInput.onfocus = () => { questionInput.style.borderBottomColor = '#3b82f6'; };
          questionInput.onblur = () => { questionInput.style.borderBottomColor = '#e2e8f0'; };

          // 4. Options Container
          const optionsCtx = document.createElement('div');
          optionsCtx.style.cssText = 'display: flex; flex-direction: column; gap: 0.75rem;';

          // 5. Render Logic
          const renderOptions = () => {
            optionsCtx.innerHTML = '';
            node.attrs.options.forEach((option, index) => {
              const row = document.createElement('div');
              row.style.cssText = 'display: flex; align-items: center; gap: 0.75rem; width: 100%;';

              // Correct Toggle
              const checkbox = document.createElement('button');
              checkbox.style.cssText = `
                width: 24px;
                height: 24px;
                border-radius: 6px;
                border: 2px solid ${option.isCorrect ? '#22c55e' : '#cbd5e1'};
                background: ${option.isCorrect ? '#22c55e' : 'transparent'};
                color: white;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                flex-shrink: 0;
                transition: all 0.2s;
                padding: 0;
              `;
              if (option.isCorrect) {
                checkbox.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
              }

              checkbox.onmousedown = (e) => {
                e.preventDefault();
                // Single choice logic: Toggle clicked option, reset others to false
                const newOptions = node.attrs.options.map((opt, i) => ({
                  ...opt,
                  isCorrect: i === index ? !opt.isCorrect : false
                }));
                updateAttrs({ options: newOptions });
              };

              // Text Input
              const input = document.createElement('input');
              input.type = 'text';
              input.value = option.text;
              input.placeholder = `Option ${index + 1}`;
              input.style.cssText = `
                flex: 1;
                padding: 0.5rem 0.75rem;
                border: 1px solid ${option.isCorrect ? '#86efac' : '#e2e8f0'};
                border-radius: 0.5rem;
                font-size: 0.95rem;
                color: #334155;
                outline: none;
                transition: all 0.2s;
                background: ${option.isCorrect ? '#f0fdf4' : 'transparent'};
              `;

              input.oninput = (e) => {
                const newOptions = [...node.attrs.options];
                newOptions[index] = { ...newOptions[index], text: e.target.value };
                updateAttrs({ options: newOptions });
              };

              input.onfocus = () => { if (!option.isCorrect) input.style.borderColor = '#3b82f6'; };
              input.onblur = () => { if (!option.isCorrect) input.style.borderColor = '#e2e8f0'; };

              // Delete Button
              const del = document.createElement('button');
              del.innerHTML = '√ó';
              del.style.cssText = `
                 width: 24px;
                 height: 24px;
                 display: flex;
                 align-items: center;
                 justify-content: center;
                 border: none;
                 background: transparent;
                 color: #94a3b8;
                 cursor: pointer;
                 font-size: 20px;
                 border-radius: 4px;
                 transition: color 0.2s;
                 line-height: 1;
                 padding: 0;
              `;
              del.onmouseenter = () => del.style.color = '#ef4444';
              del.onmouseleave = () => del.style.color = '#94a3b8';
              del.onmousedown = (e) => {
                e.preventDefault();
                const newOptions = node.attrs.options.filter((_, i) => i !== index);
                updateAttrs({ options: newOptions });
              };

              row.append(checkbox, input, del);
              optionsCtx.appendChild(row);
            });
          };

          renderOptions();

          // 6. Add Button
          const addBtn = document.createElement('button');
          addBtn.innerHTML = '+ Add Option';
          addBtn.style.cssText = `
            margin-top: 1rem;
            padding: 0.5rem 1rem;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            color: #475569;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
          `;
          addBtn.onmouseenter = () => { addBtn.style.background = '#f1f5f9'; addBtn.style.color = '#1e293b'; };
          addBtn.onmouseleave = () => { addBtn.style.background = '#f8fafc'; addBtn.style.color = '#475569'; };
          addBtn.onmousedown = (e) => {
            e.preventDefault();
            const newId = Math.random().toString(36).slice(2, 9);
            const newOptions = [...node.attrs.options, { id: newId, text: '', isCorrect: false }];
            updateAttrs({ options: newOptions });
          };

          dom.append(questionInput, optionsCtx, addBtn);

          return {
            dom,
            ignoreMutation: (mutation) => {
              // Internal updates (handled by listeners) should be ignored by ProseMirror
              if (dom.contains(mutation.target)) return true;
              return false;
            },
            stopEvent: (event) => {
              // Allow input interaction, block everything else to prevent selection weirdness
              if (event.target.tagName === 'INPUT') return true;
              if (event.type === 'dragstart' && !dom.contains(event.target)) return false;
              return false;
            },
            update: (updatedNode) => {
              if (updatedNode.type.name !== 'mcq') return false;

              // Question Sync
              if (updatedNode.attrs.question !== node.attrs.question) {
                questionInput.value = updatedNode.attrs.question;
              }

              // Options Sync
              if (JSON.stringify(updatedNode.attrs.options) !== JSON.stringify(node.attrs.options)) {
                node = updatedNode;

                // Check if only visual updates are needed to preserve focus
                const inputs = optionsCtx.querySelectorAll('input[type="text"]');
                let domMatches = true;

                if (inputs.length !== node.attrs.options.length) domMatches = false;
                else {
                  node.attrs.options.forEach((opt, i) => {
                    if (inputs[i].value !== opt.text) domMatches = false;
                  });
                }

                if (!domMatches) {
                  renderOptions();
                } else {
                  // Update visuals only
                  Array.from(optionsCtx.children).forEach((row, i) => {
                    const opt = node.attrs.options[i];
                    if (opt && row) {
                      const cb = row.children[0];
                      const inp = row.children[1];

                      cb.style.borderColor = opt.isCorrect ? '#22c55e' : '#cbd5e1';
                      cb.style.background = opt.isCorrect ? '#22c55e' : 'transparent';
                      cb.innerHTML = opt.isCorrect ? `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>` : '';

                      inp.style.borderColor = opt.isCorrect ? '#86efac' : (document.activeElement === inp ? '#3b82f6' : '#e2e8f0');
                      inp.style.background = opt.isCorrect ? '#f0fdf4' : 'transparent';
                    }
                  });
                }
              } else {
                node = updatedNode;
              }
              return true;
            },
            selectNode: () => {
              dom.style.borderColor = '#3b82f6';
              dom.style.boxShadow = '0 0 0 3px rgba(59, 130, 246, 0.1)';
            },
            deselectNode: () => {
              dom.style.borderColor = '#e2e8f0';
              dom.style.boxShadow = '0 4px 6px -1px rgba(0, 0, 0, 0.1)';
            }
          };
        }
      }
    });

    /* --- Slash Menu Configuration --- */
    const slashGroups = [
      {
        title: 'Text',
        items: [
          { title: 'Paragraph', icon: 'T', action: editor => editor.chain().focus().setParagraph().run() },
          { title: 'Heading 1', icon: 'H1', action: editor => editor.chain().focus().toggleHeading({ level: 1 }).run() },
          { title: 'Heading 2', icon: 'H2', action: editor => editor.chain().focus().toggleHeading({ level: 2 }).run() },
          { title: 'Heading 3', icon: 'H3', action: editor => editor.chain().focus().toggleHeading({ level: 3 }).run() },
          { title: 'Bullet List', icon: '‚Ä¢', action: editor => editor.chain().focus().toggleBulletList().run() },
          { title: 'Numbered List', icon: '1.', action: editor => editor.chain().focus().toggleOrderedList().run() },
        ]
      },
      {
        title: 'Media',
        items: [
          {
            title: 'Image',
            description: 'Upload an image',
            icon: 'üñºÔ∏è',
            action: async (editor) => {
              const file = await triggerFileUpload('image/*');
              if (file) editor.chain().focus().setImage({ src: file.src }).run();
            }
          },
          {
            title: 'Video',
            description: 'Upload a video',
            icon: 'üìπ',
            action: async (editor) => {
              const file = await triggerFileUpload('video/*');
              if (file) editor.chain().focus().insertContent({ type: 'video', attrs: { src: file.src } }).run();
            }
          },
          {
            title: 'File',
            description: 'Upload a file attachment',
            icon: 'üìé',
            action: async (editor) => {
              const file = await triggerFileUpload('*/*');
              if (file) editor.chain().focus().insertContent({ type: 'fileAttachment', attrs: { src: file.src, name: file.name, size: file.size } }).run();
            }
          },
          {
            title: 'Embed URL',
            description: 'YouTube, Link, etc.',
            icon: 'üîó',
            action: async (editor) => {
              const url = await Modal.open('Insert Content', 'https://...');
              if (url) {
                if (url.includes('youtube.com') || url.includes('youtu.be')) {
                  editor.chain().focus().setYoutube({ src: url }).run();
                } else {
                  editor.chain().focus().extendMarkRange('link').setLink({ href: url }).run();
                }
              }
            }
          }
        ]
      },
      {
        title: 'AI Actions',
        items: [
          {
            title: 'Write with AI',
            description: 'Generate structured educational content',
            icon: '‚úçÔ∏è',
            action: editor => handleAIRequest('write')
          },
          { title: 'Continue', icon: '‚û°Ô∏è', action: editor => handleAIRequest('continue') },
          { title: 'Improve Writing', icon: '‚ú®', action: editor => handleAIRequest('improve') },
          { title: 'Summarize', icon: 'üìù', action: editor => handleAIRequest('summarize') },
          { title: 'Explain', icon: 'ü§î', action: editor => handleAIRequest('explain') },
          { title: 'Make Notes', icon: 'üìå', action: editor => handleAIRequest('convert-to-notes') },
          { title: 'Generate MCQ', icon: '‚ùì', action: editor => handleAIRequest('generate-mcq') },
          { title: 'Fix Grammar', icon: 'abc', action: editor => handleAIRequest('fix-grammar') },
          { title: 'Change Tone (Formal)', icon: 'üëî', action: editor => handleAIRequest('rewrite-tone', 'Formal') },
        ]
      },
      {
        title: 'Blocks',
        items: [
          { title: 'Mcq', description: 'Insert an MCQ block', icon: 'üìù', action: editor => editor.chain().focus().insertContent({ type: 'mcq', attrs: { question: 'Enter your question here?' } }).run() },
          { title: 'Table', icon: '‚ñ¶', action: editor => editor.chain().focus().insertTable({ rows: 3, cols: 3, withHeaderRow: true }).run() },
          { title: 'Code Block', icon: '{ }', action: editor => editor.chain().focus().toggleCodeBlock().run() },
          { title: 'Math Equation', description: 'Insert a block equation (LaTeX)', icon: '‚àë', action: editor => editor.chain().focus().insertContent({ type: 'mathBlock', attrs: { text: 'E = mc^2' } }).run() },
          { title: 'Info Callout', icon: 'üí°', action: editor => editor.chain().focus().insertContent({ type: 'callout', attrs: { type: 'info' }, content: [{ type: 'paragraph', content: [{ type: 'text', text: 'Enter information here...' }] }] }).run() },
          { title: 'Success Callout', icon: '‚úÖ', action: editor => editor.chain().focus().insertContent({ type: 'callout', attrs: { type: 'success' }, content: [{ type: 'paragraph', content: [{ type: 'text', text: 'Task completed successfully!' }] }] }).run() },
          { title: 'Warning Callout', icon: '‚ö†Ô∏è', action: editor => editor.chain().focus().insertContent({ type: 'callout', attrs: { type: 'warning' }, content: [{ type: 'paragraph', content: [{ type: 'text', text: 'Please be careful with this action.' }] }] }).run() },
          { title: 'Error Callout', icon: '‚õî', action: editor => editor.chain().focus().insertContent({ type: 'callout', attrs: { type: 'error' }, content: [{ type: 'paragraph', content: [{ type: 'text', text: 'An error occurred. Please check your input.' }] }] }).run() },
          { title: 'Page Break', icon: '‚úÇÔ∏è', action: editor => editor.chain().focus().insertContent({ type: 'pageBreak' }).run() }
        ]
      },
      {
        title: 'Utilities',
        items: [
          { title: 'Date', icon: 'üìÖ', action: editor => editor.chain().focus().insertContent(new Date().toLocaleDateString()).run() },
          { title: 'Time', icon: '‚è∞', action: editor => editor.chain().focus().insertContent(new Date().toLocaleTimeString()).run() },
          { title: 'Date & Time', icon: 'üìÜ', action: editor => editor.chain().focus().insertContent(new Date().toLocaleString()).run() },
          { title: 'Task List', icon: '‚òëÔ∏è', action: editor => editor.chain().focus().toggleTaskList().run() },
          { title: 'Divider', icon: '‚Äî', action: editor => editor.chain().focus().setHorizontalRule().run() },
        ]
      }
    ];

    const SlashCommand = Extension.create({
      name: 'slashCommand',
      addProseMirrorPlugins() {
        return [
          Suggestion({
            editor: this.editor,
            char: '/',
            startOfLine: false,
            items: ({ query }) => {
              return slashGroups.map(group => ({
                title: group.title,
                items: group.items.filter(item => item.title.toLowerCase().includes(query.toLowerCase()))
              })).filter(group => group.items.length > 0);
            },
            render: () => {
              let popup;
              let selectedIndex = 0;
              let suggestionProps;
              let domNodes = []; // Store references to item elements

              const renderList = () => {
                if (!popup) return;
                popup.innerHTML = '';
                domNodes = [];

                if (suggestionProps.items.length === 0) {
                  popup.style.display = 'none';
                  return;
                }
                popup.style.display = 'block';

                suggestionProps.items.forEach(group => {
                  const groupTitle = document.createElement('div');
                  groupTitle.className = 'slash-group-title';
                  groupTitle.textContent = group.title;
                  popup.appendChild(groupTitle);

                  group.items.forEach(item => {
                    const el = document.createElement('div');
                    el.className = 'slash-item';
                    el.innerHTML = `
                      <div class="slash-item-icon">${item.icon}</div>
                      <div class="slash-item-content">
                        <div class="slash-item-title">${item.title}</div>
                        ${item.description ? `<div class="slash-item-desc">${item.description}</div>` : ''}
                      </div>
                    `;

                    el.addEventListener('mousedown', (e) => {
                      e.preventDefault();
                      e.stopPropagation();
                      execute(item);
                    });

                    popup.appendChild(el);
                    domNodes.push({ el, item });
                  });
                });
              };

              const updateSelection = (scroll = false) => {
                domNodes.forEach(({ el }, index) => {
                  if (index === selectedIndex) {
                    el.classList.add('is-selected');
                    if (scroll) {
                      el.scrollIntoView({ block: 'nearest', inline: 'nearest' });
                    }
                  } else {
                    el.classList.remove('is-selected');
                  }
                });
              };

              const execute = (item) => {
                if (suggestionProps) {
                  const { editor, range } = suggestionProps;
                  editor.chain().focus().deleteRange(range).run();
                  item.action(editor);
                }
              };

              const updatePosition = () => {
                const rect = suggestionProps.clientRect();
                if (rect) {
                  popup.style.position = 'absolute';
                  popup.style.top = (rect.bottom + window.scrollY + 10) + 'px';
                  popup.style.left = rect.left + 'px';
                }
              };

              return {
                onStart: props => {
                  suggestionProps = props;
                  popup = document.createElement('div');
                  popup.className = 'slash-popup';
                  document.body.appendChild(popup);
                  selectedIndex = 0;
                  renderList();
                  updateSelection(false); // No scroll on start
                  updatePosition();
                },
                onUpdate(props) {
                  suggestionProps = props;
                  selectedIndex = 0;
                  renderList();
                  updateSelection(false); // No scroll on update
                  updatePosition();
                },
                onKeyDown(props) {
                  if (props.event.key === 'ArrowUp') {
                    selectedIndex = (selectedIndex + domNodes.length - 1) % domNodes.length;
                    updateSelection(true); // Scroll on key nav
                    return true;
                  }
                  if (props.event.key === 'ArrowDown') {
                    selectedIndex = (selectedIndex + 1) % domNodes.length;
                    updateSelection(true); // Scroll on key nav
                    return true;
                  }
                  if (props.event.key === 'Enter') {
                    if (domNodes[selectedIndex]) {
                      execute(domNodes[selectedIndex].item);
                    }
                    return true;
                  }
                  return false;
                },
                onExit() {
                  if (popup) popup.remove();
                  popup = null;
                  domNodes = [];
                }
              };
            }
          })
        ];
      }
    });

    /* --- Persistence & Initialization --- */
    const STORAGE_KEY = 'tiptap-premium-editor-content';
    const DEFAULT_CONTENT = {
      type: 'doc',
      content: [
        {
          type: 'heading',
          attrs: { level: 1 },
          content: [{ type: 'text', text: 'Premium Editor' }]
        },
        {
          type: 'paragraph',
          content: [
            { type: 'text', text: 'This is a polished TipTap editor with ' },
            { type: 'text', marks: [{ type: 'bold' }], text: 'Code highlighting' },
            { type: 'text', text: ', ' },
            { type: 'text', marks: [{ type: 'bold' }], text: 'Math' },
            { type: 'text', text: ' support, and better UI.' }
          ]
        },
        {
          type: 'codeBlock',
          attrs: { language: 'javascript' },
          content: [{ type: 'text', text: "console.log('Hello World');" }]
        },
        {
          type: 'callout',
          attrs: { type: 'info' },
          content: [{
            type: 'paragraph',
            content: [
              { type: 'text', text: 'Try typing ' },
              { type: 'text', marks: [{ type: 'code' }], text: '/' },
              { type: 'text', text: ' to see the grouped menu.' }
            ]
          }]
        }
      ]
    };

    const savedContent = localStorage.getItem(STORAGE_KEY);
    const initialContent = savedContent ? JSON.parse(savedContent) : DEFAULT_CONTENT;

    const editor = new Editor({
      element: document.querySelector('#editor'),
      extensions: [
        Document,
        Paragraph,
        Text,
        Blockquote,
        BulletList,
        OrderedList,
        ListItem,
        HardBreak,
        HorizontalRule,
        Markdown.configure({
          html: false,
          tightLists: true,
          bulletListMarker: '-',
          linkify: true,
          transformPastedText: true,
          transformCopiedText: true,
        }),
        Heading.configure({ levels: [1, 2, 3] }),
        Bold,
        Code,
        Italic,
        Strike,
        Dropcursor.configure({ color: '#3b82f6', width: 2 }),
        Gapcursor,
        History,
        Placeholder.configure({
          placeholder: 'Type / for commands...',
        }),
        TaskList,
        TaskItem.configure({ nested: true }),
        Link.configure({ openOnClick: false }),
        CustomImage.configure({
          allowBase64: true,
          inline: true,
        }),
        Youtube.configure({ controls: false }),
        Table.configure({ resizable: true }),
        TableRow, TableHeader, TableCell,
        // Replace CodeBlockLowlight with CustomCodeBlock
        CustomCodeBlock.configure({
          lowlight,
          defaultLanguage: 'javascript',
        }),
        MathBlock,
        Callout,
        PageBreak,
        Mcq,
        // DateTime,
        Video,
        FileAttachment,
        SlashCommand,
        // Custom Vanilla Drag Handle
        Extension.create({
          name: 'premiumDragHandle',

          addProseMirrorPlugins() {
            return [
              new Plugin({
                key: new PluginKey('premiumDragHandle'),
                view(editorView) {
                  const handle = document.createElement('div');
                  handle.className = 'global-drag-handle';
                  handle.draggable = true;
                  document.body.appendChild(handle);

                  let currentBlock = null;
                  let frameId = null;

                  const hide = () => {
                    handle.classList.remove('visible');
                    currentBlock = null;
                  };

                  const updatePosition = (dom) => {
                    const rect = dom.getBoundingClientRect();
                    handle.style.top =
                      rect.top + window.scrollY + rect.height / 2 - 12 + 'px';
                    handle.style.left =
                      rect.left - 32 + 'px';
                    handle.classList.add('visible');
                  };

                  const onMouseMove = (e) => {
                    if (frameId) cancelAnimationFrame(frameId);
                    frameId = requestAnimationFrame(() => {
                      if (e.target === handle || handle.contains(e.target)) return;

                      const coords = { left: e.clientX, top: e.clientY };
                      const pos = editorView.posAtCoords(coords);

                      if (!pos) return hide();

                      let targetNode = null;
                      let targetPos = null;
                      let targetDom = null;

                      // 1. Check for Atom Block (MCQ, Image, etc.) directly at position
                      // pos.pos often points directly before the atom node if we hover it
                      const directNode = editorView.state.doc.nodeAt(pos.pos);
                      if (directNode && directNode.isBlock && directNode.isAtom) {
                        targetNode = directNode;
                        targetPos = pos.pos;
                        targetDom = editorView.nodeDOM(targetPos);
                      }

                      // 2. If no atom found, traverse up from the resolved position
                      if (!targetNode) {
                        const $pos = editorView.state.doc.resolve(pos.pos);
                        for (let depth = $pos.depth; depth > 0; depth--) {
                          const node = $pos.node(depth);
                          // We are looking for the "best" block to drag.
                          // If it's a block and not doc
                          if (node.isBlock && node.type.name !== 'doc') {

                            // Priority Logic:
                            // If the parent is a "List Item" or "Callout", we likely want to drag that instead of the paragraph inside.
                            const parent = $pos.node(depth - 1);
                            if (parent && (parent.type.name === 'callout' || parent.type.name === 'listItem' || parent.type.name === 'mcq')) {
                              // Skip this node, let the loop find the parent in next iteration
                              continue;
                            }

                            targetNode = node;
                            targetPos = $pos.before(depth);
                            targetDom = editorView.nodeDOM(targetPos);
                            break;
                          }
                        }
                      }

                      if (targetNode && targetDom && targetDom.nodeType === 1) {
                        const rect = targetDom.getBoundingClientRect();

                        // Show if near left side (-50px to +100px of left start)
                        // Relaxed constraints to ensure it pops up easier
                        if (e.clientX < rect.left - 50 || e.clientX > rect.left + rect.width) {
                          // Too far away
                        } else {
                          currentBlock = { pos: targetPos, dom: targetDom };
                          updatePosition(targetDom);
                          return;
                        }
                      }

                      // Safe zone check (keep visible if moving towards handle)
                      if (currentBlock) {
                        const rect = currentBlock.dom.getBoundingClientRect();
                        const handleRect = handle.getBoundingClientRect();

                        if (e.clientY >= rect.top - 20 && e.clientY <= rect.bottom + 20 &&
                          e.clientX >= handleRect.left - 20 && e.clientX <= rect.left + 50) {
                          return;
                        }
                      }

                      hide();
                    });
                  };

                  // Drag Start
                  handle.addEventListener('dragstart', (e) => {
                    if (!currentBlock || !currentBlock.dom) {
                      e.preventDefault();
                      return;
                    }

                    const { pos, dom } = currentBlock;

                    // Safe check if pos is valid
                    try {
                      const tr = editorView.state.tr.setSelection(
                        NodeSelection.create(editorView.state.doc, pos)
                      );
                      editorView.dispatch(tr);
                    } catch (err) {
                      e.preventDefault();
                      return;
                    }

                    const slice = editorView.state.selection.content();
                    const serializer = DOMSerializer.fromSchema(editorView.state.schema);
                    const fragment = serializer.serializeFragment(slice.content);

                    const wrapper = document.createElement('div');
                    wrapper.appendChild(fragment);

                    if (e.dataTransfer) {
                      e.dataTransfer.setData('text/html', wrapper.innerHTML);
                      e.dataTransfer.setData('text/plain', wrapper.innerText || wrapper.textContent || '');
                      e.dataTransfer.effectAllowed = 'copyMove';
                      e.dataTransfer.setDragImage(dom, 0, 0);
                    }
                    editorView.dragging = { slice, move: true };
                  });

                  // Auto Scroll during Drag
                  handle.addEventListener('drag', (e) => {
                    // Filter out invalid 0 coordinates often sent on dragend
                    if (e.clientY === 0 && e.clientX === 0) return;

                    const y = e.clientY;
                    const h = window.innerHeight;

                    // Scroll faster as you get closer to edge
                    if (y < 50) {
                      window.scrollBy(0, -15);
                    } else if (y < 100) {
                      window.scrollBy(0, -5);
                    } else if (y > h - 50) {
                      window.scrollBy(0, 15);
                    } else if (y > h - 100) {
                      window.scrollBy(0, 5);
                    }
                  });

                  document.addEventListener('mousemove', onMouseMove);

                  return {
                    destroy() {
                      handle.remove();
                      document.removeEventListener('mousemove', onMouseMove);
                    }
                  };
                }
              })
            ];
          }
        }),

        BubbleMenu.configure({
          pluginKey: 'tableBubbleMenu', // Using string key is safer for Tiptap configure unless using exact object ref
          element: document.querySelector('#table-bubble-menu'),
          shouldShow: ({ editor }) => editor.isActive('table')
        }),

        BubbleMenu.configure({
          pluginKey: 'aiBubbleMenu',
          element: document.querySelector('#ai-bubble-menu'),
          shouldShow: ({ editor, from, to }) =>
            !editor.state.selection.empty && !editor.isActive('table')
        })

      ],
      content: initialContent,
      editorProps: {
        attributes: {
          class: 'prose prose-sm sm:prose lg:prose-lg xl:prose-2xl focus:outline-none',
        },
      },
      onUpdate({ editor }) {
        const json = editor.getJSON();
        localStorage.setItem(STORAGE_KEY, JSON.stringify(json));
        document.getElementById('debug-json').textContent = JSON.stringify(json, null, 2);
      }
    });

    // Initial Render
    document.getElementById('debug-json').textContent = JSON.stringify(editor.getJSON(), null, 2);

    // Populate Table Bubble Menu
    const tableMenuContainer = document.querySelector('#table-bubble-menu');
    if (tableMenuContainer) tableMenuContainer.className = 'bubble-menu hidden';

    // Helper to create buttons
    const createBtn = (icon, action, title, isDestructive = false) => {
      const btn = document.createElement('button');
      btn.className = `bubble-btn ${isDestructive ? 'text-red-500 hover:text-red-700 hover:bg-red-50' : ''}`;
      btn.innerHTML = icon;
      btn.title = title;
      btn.onclick = () => editor.chain().focus()[action]().run();
      return btn;
    };

    if (tableMenuContainer) {
      tableMenuContainer.append(
        createBtn('‚Üê', 'addColumnBefore', 'Add Col Before'),
        createBtn('‚Üí', 'addColumnAfter', 'Add Col After'),
        createBtn('‚Üë', 'addRowBefore', 'Add Row Before'),
        createBtn('‚Üì', 'addRowAfter', 'Add Row After'),
        createBtn('üóëÔ∏è', 'deleteTable', 'Delete Table', true)
      );
    }

    /* --- Advanced AI Module (Refactored) --- */

    // 1. AI UI System
    const aiUI = {
      overlay: document.getElementById('ai-preview-overlay'),
      content: document.getElementById('ai-preview-content'),
      status: document.getElementById('ai-status'),
      acceptBtn: document.getElementById('ai-accept'),
      rejectBtn: document.getElementById('ai-reject'),
      resolvePromise: null,

      show() {
        this.overlay.classList.remove('hidden');
        this.content.innerHTML = '';
        this.status.textContent = 'Thinking...';
        this.status.className = 'text-xs text-blue-500 animate-pulse';
        this.acceptBtn.disabled = true;
      },

      hide() {
        this.overlay.classList.add('hidden');
        this.resolvePromise = null;
      },

      updatePreview(html) {
        this.content.innerHTML = html;
        this.content.scrollTop = this.content.scrollHeight;
      },

      setSuccess() {
        this.status.textContent = 'Generated';
        this.status.className = 'text-xs text-green-600 font-bold';
        this.acceptBtn.disabled = false;
      },

      setError(msg) {
        this.status.textContent = 'Error';
        this.status.className = 'text-xs text-red-600 font-bold';
        this.content.innerHTML = `<p class="text-red-500">${msg}</p>`;
      },

      async waitForUser() {
        return new Promise((resolve) => {
          this.resolvePromise = resolve;
          this.acceptBtn.onclick = () => resolve(true);
          this.rejectBtn.onclick = () => resolve(false);
        });
      }
    };

    // --- Custom Block Converter ---
    const convertCustomBlocks = () => {
      const { state, view } = editor;
      const { doc } = state;
      let tr = state.tr;
      let modified = false;

      doc.descendants((node, pos) => {
        if (!node.isTextblock || node.type.name !== 'paragraph') return;
        const text = node.textContent;

        // 1. Math Block: $$ ... $$
        // Simple check for full block math
        if (text.trim().startsWith('$$') && text.trim().endsWith('$$')) {
          const mathText = text.trim().slice(2, -2).trim();
          if (mathText) {
            tr.replaceWith(pos, pos + node.nodeSize,
              state.schema.nodes.mathBlock.create({ text: mathText })
            );
            modified = true;
            return false; // Don't descend
          }
        }

        // 2. MCQ: ? Question ... ( ) Option
        if (text.trim().startsWith('? ')) {
          // Check if next siblings are options
          // This is hard in descendants loop due to isolation.
          // Better strategy: Scan document text for patterns.
        }
      });

      // Scan for MCQs using text search on the full document
      // We look for blocks: ? Question \n ( ) Option ...
      // Since Tiptap Markdown splits them into paragraphs, we look for sequence of paragraphs.

      // Implementation: Iterate top-level nodes
      let i = 0;
      while (i < doc.childCount) {
        const child = doc.child(i);
        const pos = doc.resolve(0).posAtIndex(i); // Approximate
        // Wait, getting absolute pos from index is tricky.
        // Better to iterate index.

        if (child.type.name === 'paragraph' && child.textContent.startsWith('? ')) {
          const question = child.textContent.slice(2).trim();
          const options = [];
          let j = i + 1;
          let deleteCount = 1;

          while (j < doc.childCount) {
            const nextNode = doc.child(j);
            const nextText = nextNode.textContent.trim();
            if (nextNode.type.name === 'paragraph' && /^\(\s*[x\s]?\s*\)/.test(nextText)) {
              const isCorrect = nextText.match(/^\(\s*x\s*\)/i);
              const optText = nextText.replace(/^\(\s*[x\s]?\s*\)\s*/, '');
              options.push({ text: optText, isCorrect: !!isCorrect, id: Math.random().toString(36).slice(2) });
              deleteCount++;
              j++;
            } else {
              break;
            }
          }

          if (options.length > 0) {
            // Found a MCQ cluster! Replace child i to child i+deleteCount-1
            // Calculate startPos and endPos
            let startPos = 0;
            let current = 0;
            doc.forEach((n, offset) => {
              if (current === i) startPos = offset;
              current++;
            });

            // Helper to find position
            // Actually simplest is using range of nodes
            // We know startPos. We need endPos.
            // The scan above is abstract. Let's use `posAtIndex`.
          }
        }
        i++;
      }
      // ... (Simpler Implementation below using range replacement) ...
    };

    // Robust ConvertCustomBlocks
    // We rewrite the document by replacing text blocks with Nodes
    const convertCustomBlocksRobust = () => {
      const updates = [];

      // 1. Math Block & Single-Node MCQ Detection
      editor.state.doc.forEach((node, offset) => {
        if (node.type.name === 'paragraph') {
          const text = node.textContent.trim();

          // Math Block
          if (text.startsWith('$$') && text.endsWith('$$')) {
            updates.push({
              from: offset,
              to: offset + node.nodeSize,
              type: 'mathBlock',
              attrs: { text: text.slice(2, -2).trim() }
            });
            return;
          }

          // Callout Block Detection
          if (text.startsWith('! ')) {
            const types = ['info', 'success', 'warning', 'error'];
            let detectedType = 'info';
            let contentText = text.slice(2).trim();

            for (const t of types) {
              if (text.startsWith(`!${t} `)) {
                detectedType = t;
                contentText = text.slice(t.length + 2).trim();
                break;
              }
            }

            updates.push({
              from: offset,
              to: offset + node.nodeSize,
              type: 'callout',
              attrs: { type: detectedType },
              // We need to create the content manually during mapping if possible,
              // but convertCustomBlocksRobust uses replaceWith.
              // We'll wrap the text in a paragraph node inside the callout.
              content: contentText
            });
            return;
          }
          // Detect proper $$ block

          // Detect multiple inline math lines stacked
          if (/^(\$.*\$\n?)+$/.test(node.textContent.trim())) {
            const mathText = node.textContent.replace(/\$/g, '').trim();
            updates.push({
              from: offset,
              to: offset + node.nodeSize,
              type: 'mathBlock',
              attrs: { text: mathText }
            });
          }

          // Single-Paragraph MCQ (e.g. "? Q\n( ) A\n( ) B")
          const lines = text.split('\n').map(l => l.trim()).filter(l => l);
          if (lines.length >= 2 && lines[0].startsWith('? ')) {
            const question = lines[0].slice(2).trim();
            const options = [];

            // Parse options
            for (let i = 1; i < lines.length; i++) {
              if (/^\(\s*[x\s]?\s*\)/.test(lines[i])) {
                const isCorrect = /^\(\s*x\s*\)/i.test(lines[i]);
                const optText = lines[i].replace(/^\(\s*[x\s]?\s*\)\s*/, '');
                options.push({ text: optText, isCorrect, id: Math.random().toString(36).slice(2) });
              }
            }

            if (options.length >= 2) {
              updates.push({
                from: offset,
                to: offset + node.nodeSize,
                type: 'mcq',
                attrs: { question, options }
              });
              return;
            }
          }
        }
      });

      // 2. Multi-Paragraph MCQ Detection
      // Scan for sequences of paragraphs: "? Q" -> "( ) A" -> "( ) B"
      let mcqStart = -1;
      let questionText = '';
      let options = [];
      let nodesToRemove = [];

      editor.state.doc.forEach((node, offset) => {
        // Skip if already handled
        if (updates.some(u => u.from === offset)) return;

        if (node.type.name === 'paragraph') {
          const text = node.textContent.trim();

          // Start of Question
          if (text.startsWith('? ')) {
            if (mcqStart !== -1) {
              // Close previous (was invalid or incomplete)
              mcqStart = -1;
              options = [];
              nodesToRemove = [];
            }
            mcqStart = offset;
            questionText = text.slice(2).trim();
            nodesToRemove.push({ from: offset, to: offset + node.nodeSize });
            return;
          }

          // Option
          if (mcqStart !== -1 && /^\(\s*[x\s]?\s*\)/.test(text)) {
            const isCorrect = /^\(\s*x\s*\)/i.test(text);
            const optText = text.replace(/^\(\s*[x\s]?\s*\)\s*/, '');
            options.push({ text: optText, isCorrect, id: Math.random().toString(36).slice(2) });
            nodesToRemove.push({ from: offset, to: offset + node.nodeSize });
            return;
          }

          // End of MCQ Cluster
          if (mcqStart !== -1) {
            if (options.length > 0) {
              updates.push({
                from: nodesToRemove[0].from,
                to: nodesToRemove[nodesToRemove.length - 1].to,
                type: 'mcq',
                attrs: { question: questionText, options: [...options] }
              });
            }
            mcqStart = -1;
            options = [];
            nodesToRemove = [];
          }
        }
      });

      // Catch trailing MCQ
      if (mcqStart !== -1 && options.length > 0) {
        updates.push({
          from: nodesToRemove[0].from,
          to: nodesToRemove[nodesToRemove.length - 1].to,
          type: 'mcq',
          attrs: { question: questionText, options: [...options], markdown: fullMarkdown }
        });
      }

      // Apply updates (Bottom-Up order)
      if (updates.length > 0) {
        updates.sort((a, b) => b.from - a.from);
        const transaction = editor.state.tr;
        updates.forEach(u => {
          if (u.type === 'callout') {
            // Special handling for callout (block+ node)
            const paragraph = editor.schema.nodes.paragraph.create(null, editor.schema.text(u.content || ''));
            transaction.replaceWith(u.from, u.to, editor.schema.nodes.callout.create(u.attrs, paragraph));
          } else {
            transaction.replaceWith(u.from, u.to, editor.schema.nodes[u.type].create(u.attrs));
          }
        });
        editor.view.dispatch(transaction);
      }
    };

    // 2. Prompt Builder (PURE MARKDOWN MODE)
    const buildPrompt = (action, selection, fullDoc, param = '') => {

      const baseSystem = `
You are an AI writing assistant for a structured rich text editor.

You MUST output STRICT MARKDOWN ONLY.
Do NOT use JSON.
Do NOT use HTML.
Do NOT wrap entire response in a single code block.
Do NOT add conversational phrases like "Here is" or "Sure".

==============================
FORMATTING RULES (MANDATORY)
==============================

HEADINGS
- Use # for main title
- Use ## for sections
- Use ### for subsections
- Do NOT use #### or deeper

PARAGRAPHS
- Maximum 4 lines per paragraph
- Always leave ONE blank line between paragraphs
- Never output one large paragraph

BULLET LIST
- Use "- " only
- Leave one blank line before list
- Do NOT use "*"

NUMBERED LIST
1. Step one
2. Step two
- Leave one blank line before list

CODE BLOCK
Use triple backticks with language:
\`\`\`python
code here
\`\`\`
Only use code blocks if user asks for example code.

MATH
Inline math: $a^2 + b^2$
Block math:
$$
a^2 + b^2 = c^2
$$
Always place block math on separate lines.

==============================
MCQ FORMAT (ONLY IF USER ASKS)
==============================

Use EXACT format:

? Question text
( ) Option A
(x) Correct Option
( ) Option C
( ) Option D

Rules:
- Each option MUST be on a new line
- "(x)" marks the correct answer
- Leave one blank line between questions
- Do NOT use markdown formatting inside MCQ
- Do NOT mix explanation inside MCQ block

If user asks for both explanation and MCQ:
1. Write explanation first
2. Leave one blank line
3. Then write MCQ section

Output only structured educational content.
`;

      const context = fullDoc.slice(-3000);

      let prompt = '';

      switch (action) {

        case 'improve':
          prompt = `
Rewrite the following text to be professional, clear, and educational.

Text:
"${selection}"
`;
          break;

        case 'summarize':
          prompt = `
Summarize the following content in structured bullet format.

Text:
"${selection}"
`;
          break;

        case 'explain':
          prompt = `
Explain this concept clearly for students.
Use structured sections if helpful.

Text:
"${selection}"
`;
          break;

        case 'continue':
          prompt = `
Continue the document naturally from where it ends.

Rules:
- Do NOT rewrite existing content.
- Maintain the same heading hierarchy.
- Add new sections if appropriate.
- Output STRICT MARKDOWN only.
- Do not use JSON.

Document Context:
${context}
`;
          break;

          break;

        case 'convert-to-notes':
          prompt = `
Convert this content into structured study notes.
Use headings and bullet points where appropriate.

Text:
"${selection}"
`;
          break;

        case 'fix-grammar':
          prompt = `
Correct ONLY grammar and spelling mistakes.

STRICT RULES:
- Do NOT rewrite sentences.
- Do NOT improve wording.
- Do NOT add new sentences.
- Do NOT remove content.
- Do NOT change structure.
- Keep the exact same formatting.
- Return the same number of sentences.
- If there are no grammar mistakes, return the original text unchanged.

Text:
"${selection}"
`;

          break;

        case 'rewrite-tone':
          prompt = `
Rewrite ONLY the provided text in ${param} tone.

STRICT RULES:
- Do NOT add new information.
- Do NOT add headings.
- Do NOT reference other document sections.
- Do NOT expand beyond the original idea.
- Keep it approximately the same length.
- Output only the rewritten sentence.

Text:
"${selection}"
`;
          break;
          break;

        case 'generate-mcq':
          prompt = `
Generate multiple choice questions using the EXACT MCQ format defined above.

Text:
"${selection}"
`;
          break;

        case 'write':
          prompt = `
Generate structured educational content based on the following instruction.
Use headings, paragraphs, lists, math, or code if appropriate.

Instruction:
"${selection}"
`;
          break;

        default:
          prompt = `
${action}

Text:
"${selection}"
`;
      }

      return `${baseSystem}\n\n${prompt}`;
    };

    // 3. Main Handler
    const handleAIRequest = async (action, param) => {
      const { state } = editor;
      let { from, to } = state.selection;
      let selectedText = state.doc.textBetween(from, to, ' ');
      let range = { from, to };
      let mode = 'replace';

      // Context Fallback
      if (!selectedText.trim()) {
        if (action === 'continue') {
          selectedText = state.doc.textBetween(Math.max(0, from - 1500), from, ' ');
          mode = 'append';
          range = { from, to }; // Insert at cursor
        } else {
          const node = state.doc.nodeAt(from) || state.doc.resolve(from).parent;
          if (node && node.isTextblock) {
            selectedText = node.textContent;
            const pos = state.doc.resolve(from);
            range = { from: pos.start(), to: pos.end() };
          }
        }
      }

      if (!selectedText.trim()) {
        if (action === 'write') {
          selectedText = editor.getText(); // full context
          mode = 'append';
          range = { from, to };
        } else {
          alert("Please select text or text block.");
          return;
        }
      }


      // UI Start
      aiUI.show();

      try {
        const prompt = buildPrompt(action, selectedText, editor.getText(), param);

        const res = await fetch(GEMINI_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
        });

        const data = await res.json();
        if (data.error) throw new Error(data.error.message);

        let aiText = data.candidates?.[0]?.content?.parts?.[0]?.text || '';

        // Clean AI Text
        aiText = aiText.trim();
        if (aiText.startsWith('```')) aiText = aiText.replace(/^```(\w+)?/, '').replace(/```$/, '');

        // Preview (Simple Text)
        const previewHTML = `<div class="prose prose-sm font-sans p-2">${aiText.replace(/\n/g, '<br>')}</div>`;

        aiUI.updatePreview(previewHTML);
        aiUI.setSuccess();

        const userConfirmed = await aiUI.waitForUser();
        if (userConfirmed) {
          const chain = editor.chain().focus();

          if (mode !== 'append') {
            chain.deleteRange(range);
          }

          // Insert Markdown directly per User Architecture
          try {
            // Try inserting as markdown. If extension is active, this should work.
            chain.insertContentAt(mode === 'append' ? range.to : range.start || range.from, aiText, {
              contentType: 'markdown'
            });
          } catch (err) {
            console.warn("Markdown insert failed, falling back to text", err);
            chain.insertContentAt(mode === 'append' ? range.to : range.start || range.from, aiText);
          }

          chain.run();

          // Post-Process Custom Blocks (Math, MCQ)
          setTimeout(() => {
            if (typeof convertCustomBlocksRobust === 'function') {
              convertCustomBlocksRobust();
            }
          }, 50);
        }

      } catch (e) {
        console.error(e);
        aiUI.setError(e.message);
        // Allow user to close error
        await aiUI.waitForUser();
      } finally {
        aiUI.hide();
      }
    };

    // Attach to buttons
    document.querySelectorAll('.ai-btn').forEach(btn => {
      btn.onclick = (e) => {
        e.preventDefault();
        handleAIRequest(btn.dataset.action);
      };
    });

  </script>
</body>

</html>