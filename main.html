<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TipTap ‚Äî Premium Editor</title>

  <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
  <link
    href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800&family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap"
    rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">

  <style>
    /* Premium Design System */
    :root {
      --plate-bg: #ffffff;
      --plate-border: #e2e8f0;
      --plate-accent: #3b82f6;
      --font-outfit: 'Outfit', sans-serif;
      --font-inter: 'Inter', sans-serif;
      --font-mono: 'JetBrains Mono', monospace;
    }

    body {
      font-family: var(--font-inter);
      background: #f8fafc;
      min-height: 100vh;
      color: #1e293b;
    }

    /* Custom Scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }

    ::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 10px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #94a3b8;
    }

    /* Editor Canvas */
    .ProseMirror {
      outline: none;
      min-height: 600px;
      padding: 60px 80px;
      font-size: 1.05rem;
      line-height: 1.8;
    }

    @media (max-width: 768px) {
      .ProseMirror {
        padding: 40px 24px;
      }
    }

    /* Typography */
    .ProseMirror h1,
    .ProseMirror h2,
    .ProseMirror h3 {
      font-family: var(--font-outfit);
      color: #0f172a;
      line-height: 1.2;
    }

    .ProseMirror h1 {
      font-size: 2.75rem;
      font-weight: 800;
      margin: 2.5rem 0 1.5rem;
    }

    .ProseMirror h2 {
      font-size: 2rem;
      font-weight: 700;
      margin: 2rem 0 1rem;
    }

    .ProseMirror h3 {
      font-size: 1.5rem;
      font-weight: 600;
      margin: 1.5rem 0 0.75rem;
    }

    .ProseMirror p {
      margin-bottom: 1.25rem;
    }

    .ProseMirror a {
      color: var(--plate-accent);
      text-decoration: underline;
      cursor: pointer;
    }

    .global-drag-handle {
      position: absolute;
      width: 24px;
      height: 24px;
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: grab;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.08);
      transition: opacity 0.15s ease, transform 0.15s ease;
      opacity: 0;
      pointer-events: none;
    }

    .global-drag-handle.visible {
      opacity: 1;
      pointer-events: auto;
      transform: translateX(-4px);
    }

    .global-drag-handle::after {
      content: "‚ãÆ‚ãÆ";
      font-size: 14px;
      color: #94a3b8;
    }

    .global-drag-handle:hover {
      background: #f8fafc;
      border-color: #cbd5e1;
    }

    .global-drag-handle:active {
      cursor: grabbing;
    }

    /* Lists */
    .ProseMirror ul,
    .ProseMirror ol {
      padding: 0 1rem;
      margin: 1.25rem 1rem 1.25rem 0.4rem;
    }

    .ProseMirror ul li {
      list-style-type: disc;
    }

    .ProseMirror ol li {
      list-style-type: decimal;
    }

    .ProseMirror li {
      margin-bottom: 0.5rem;
      padding-left: 0.5rem;
    }

    /* Task List */
    ul[data-type="taskList"] {
      list-style: none;
      padding: 0;
    }

    ul[data-type="taskList"] li {
      display: flex;
      gap: 12px;
      margin-bottom: 8px;
      align-items: flex-start;
    }

    ul[data-type="taskList"] li>label {
      flex: 0 0 auto;
      margin-right: 0.5rem;
      user-select: none;
      margin-top: 0.3em;
    }

    ul[data-type="taskList"] li>div {
      flex: 1 1 auto;
    }

    ul[data-type="taskList"] input[type="checkbox"] {
      cursor: pointer;
      width: 1.1em;
      height: 1.1em;
      accent-color: var(--plate-accent);
    }

    ul[data-type="taskList"] li[data-checked="true"]>div {
      text-decoration: line-through;
      color: #94a3b8;
    }

    /* Blockquote */
    .ProseMirror blockquote {
      border-left: 4px solid var(--plate-accent);
      margin: 1.5rem 0;
      padding-left: 1rem;
      font-style: italic;
      color: #475569;
      background: #f8fafc;
      padding: 1rem;
      border-radius: 0 8px 8px 0;
    }

    /* Code Block */
    pre {
      background: #0d1117;
      border-radius: 0.75rem;
      color: #c9d1d9;
      font-family: var(--font-mono);
      padding: 2.5rem 1.5rem 1.5rem;
      margin: 1.5rem 0;
      position: relative;
      overflow-x: auto;
    }

    pre code {
      background: none;
      color: inherit;
      font-size: 0.85rem;
      padding: 0;
    }

    .hljs-comment,
    .hljs-quote {
      color: #8b949e;
    }

    .hljs-variable,
    .hljs-template-variable,
    .hljs-tag,
    .hljs-name,
    .hljs-selector-id,
    .hljs-selector-class,
    .hljs-regexp,
    .hljs-deletion {
      color: #d2a8ff;
    }

    .hljs-number,
    .hljs-built_in,
    .hljs-builtin-name,
    .hljs-literal,
    .hljs-type,
    .hljs-params,
    .hljs-meta,
    .hljs-link {
      color: #79c0ff;
    }

    .hljs-section,
    .hljs-title {
      color: #d2a8ff;
    }

    .hljs-keyword,
    .hljs-selector-tag {
      color: #ff7b72;
    }

    /* Language Selecror */
    .language-selector {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      background: #21262d;
      color: #c9d1d9;
      border: 1px solid #30363d;
      border-radius: 4px;
      font-size: 0.75rem;
      padding: 2px 6px;
      z-index: 10;
      opacity: 0.5;
      transition: opacity 0.2s;
      cursor: pointer;
    }

    .code-block-wrapper:hover .language-selector {
      opacity: 1;
    }

    /* Tables */
    .tableWrapper {
      margin: 2rem 0;
      overflow-x: auto;
    }

    table {
      border-collapse: collapse;
      table-layout: fixed;
      width: 100%;
      margin: 0;
      overflow: hidden;
      border-radius: 8px;
    }

    td,
    th {
      min-width: 1em;
      border: 1px solid #cbd5e1;
      padding: 10px 12px;
      vertical-align: top;
      box-sizing: border-box;
      position: relative;
    }

    th {
      font-weight: 600;
      text-align: left;
      background-color: #f1f5f9;
    }

    .selectedCell:after {
      z-index: 2;
      position: absolute;
      content: "";
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      background: rgba(59, 130, 246, 0.15);
      pointer-events: none;
    }

    /* Images & Video */
    img {
      max-width: 100%;
      height: auto;
      border-radius: 12px;
      margin: 1.5rem 0;
      display: block;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
    }

    iframe {
      width: 100%;
      aspect-ratio: 16/9;
      border-radius: 12px;
      margin: 1.5rem 0;
      border: none;
      background: #000;
    }

    /* Callouts */
    .callout {
      padding: 1.25rem;
      border-radius: 0.75rem;
      margin: 1.5rem 0;
      border: 1px solid transparent;
      display: flex;
      gap: 1rem;
      align-items: flex-start;
    }

    .callout-info {
      background: #eff6ff;
      border-color: #bfdbfe;
      color: #1e40af;
    }

    .callout-success {
      background: #f0fdf4;
      border-color: #bbf7d0;
      color: #166534;
    }

    .callout-warning {
      background: #fffbeb;
      border-color: #fde68a;
      color: #92400e;
    }

    .callout-error {
      background: #fef2f2;
      border-color: #fecaca;
      color: #991b1b;
    }

    .callout div p {
      margin: 0;
    }

    .callout-icon {
      font-size: 1.25rem;
      line-height: 1;
      user-select: none;
    }

    /* Page Break */
    .page-break {
      margin: 2rem 0;
      border: none;
      border-top: 2px dashed #cbd5e1;
      position: relative;
      height: 1px;
    }

    .page-break::after {
      content: "Page Break";
      position: absolute;
      top: -10px;
      left: 50%;
      transform: translateX(-50%);
      background: #f8fafc;
      padding: 0 10px;
      color: #94a3b8;
      font-size: 0.75rem;
      font-weight: 500;
      text-transform: uppercase;
    }

    /* Math Block Improved */
    .math-block-container {
      margin: 1.5rem 0;
      border-radius: 0.5rem;
      border: 1px solid transparent;
      transition: all 0.2s;
    }

    .math-block-container:hover {
      border-color: #e2e8f0;
    }

    .math-block-container.is-editing {
      border-color: var(--plate-accent);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
      background: #fff;
    }

    .math-preview {
      padding: 1rem;
      text-align: center;
      cursor: pointer;
      min-height: 2.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f8fafc;
      border-radius: 0.5rem;
    }

    .math-preview:hover {
      background: #f1f5f9;
    }

    .math-input {
      width: 100%;
      padding: 0.75rem;
      font-family: var(--font-mono);
      font-size: 0.9rem;
      background: #1e293b;
      color: #e2e8f0;
      border: none;
      border-radius: 0 0 0.5rem 0.5rem;
      outline: none;
      resize: vertical;
      display: none;
      /* Hidden by default */
    }

    .is-editing .math-preview {
      border-radius: 0.5rem 0.5rem 0 0;
      border-bottom: 1px solid #e2e8f0;
      background: #fff;
    }

    .is-editing .math-input {
      display: block;
    }

    .katex-display {
      margin: 0 !important;
    }

    /* Slash Menu */
    .slash-popup {
      background: white;
      border: 1px solid #e2e8f0;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
      border-radius: 12px;
      width: 300px;
      max-height: 360px;
      overflow-y: auto;
      padding: 0.5rem;
      z-index: 50;
      display: none;
      /* hidden initially */
    }

    .slash-group {
      margin-bottom: 0.5rem;
    }

    .slash-group-title {
      font-size: 0.75rem;
      font-weight: 600;
      color: #94a3b8;
      padding: 0.5rem 0.75rem 0.25rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .slash-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      color: #334155;
      font-size: 0.9rem;
      transition: all 0.15s;
    }

    .slash-item:hover {
      background: #f8fafc;
    }

    .slash-item.is-selected {
      background: #eff6ff;
      color: #2563eb;
    }

    .slash-item-icon {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f1f5f9;
      border-radius: 4px;
      font-size: 0.8rem;
      color: #64748b;
    }

    .slash-item.is-selected .slash-item-icon {
      background: #dbeafe;
      color: #2563eb;
    }

    .slash-item-content {
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .slash-item-title {
      font-weight: 500;
      line-height: 1.2;
    }

    .slash-item-desc {
      font-size: 0.75rem;
      color: #94a3b8;
      line-height: 1.2;
      margin-top: 2px;
    }

    /* Placeholders */
    .is-empty::before {
      content: attr(data-placeholder);
      float: left;
      color: #adb5bd;
      pointer-events: none;
      height: 0;
    }

    /* Modal System */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
    }

    .modal-overlay.active {
      opacity: 1;
      pointer-events: all;
    }

    .modal-card {
      background: white;
      width: 100%;
      max-width: 420px;
      padding: 24px;
      border-radius: 16px;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      transform: scale(0.95);
      transition: transform 0.2s;
    }

    .modal-overlay.active .modal-card {
      transform: scale(1);
    }

    .modal-title {
      font-size: 1.25rem;
      font-weight: 700;
      margin-bottom: 1rem;
      color: #0f172a;
    }

    .modal-input {
      width: 100%;
      padding: 10px 14px;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      margin-bottom: 1.5rem;
      outline: none;
      transition: border-color 0.2s;
    }

    .modal-input:focus {
      border-color: var(--plate-accent);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
      background: rgba(59, 130, 246, 0.05);
      /* Added slight background highlight */
    }

    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
    }

    .btn {
      padding: 8px 16px;
      border-radius: 8px;
      font-weight: 500;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-secondary {
      background: #f1f5f9;
      color: #475569;
    }

    .btn-secondary:hover {
      background: #e2e8f0;
    }

    .btn-primary {
      background: var(--plate-accent);
      color: white;
    }

    .btn-primary:hover {
      background: #2563eb;
    }

    /* Bubble Menu (Tables) */
    .bubble-menu {
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      display: flex;
      padding: 4px;
      gap: 4px;
      position: absolute;
      z-index: 20;
    }

    .bubble-menu.hidden {
      display: none;
    }

    .bubble-btn {
      background: transparent;
      border: none;
      color: #64748b;
      padding: 6px;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
    }

    .bubble-btn:hover {
      background: #f1f5f9;
      color: #0f172a;
    }

    /* Resize Handles */
    .node-image,
    .node-video {
      display: block;
      /* position: relative; set by style */
      user-select: none;
      line-height: 0;
      /* Remove bottom gap */
    }

    .node-image img,
    .node-video video {
      display: block;
      width: 100%;
      height: auto;
    }

    .resize-handle {
      position: absolute;
      right: -6px;
      bottom: -6px;
      width: 12px;
      height: 12px;
      background: #3b82f6;
      border: 2px solid white;
      border-radius: 50%;
      cursor: nwse-resize;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 10;
    }

    .ProseMirror-selectednode .resize-handle,
    .node-container:hover .resize-handle {
      opacity: 1;
    }

    /* File Attachment */
    .file-attachment {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      margin: 1.5rem 0;
      text-decoration: none;
      transition: all 0.2s;
      width: fit-content;
      cursor: pointer;
    }

    .file-attachment:hover {
      background: #f1f5f9;
      border-color: #cbd5e1;
    }

    .file-icon {
      font-size: 1.5rem;
    }

    .file-info {
      display: flex;
      flex-direction: column;
    }

    .file-name {
      font-weight: 500;
      color: #334155;
      font-size: 0.95rem;
    }

    .file-size {
      font-size: 0.75rem;
      color: #64748b;
    }
  </style>
</head>

<body class="flex flex-col items-center py-12">

  <div class="w-full max-w-5xl lg:px-8">
    <!-- Header -->
    <div class="mb-10 px-6 lg:px-0 text-center">
      <h1 class="text-4xl font-extrabold tracking-tight text-slate-900 mb-2 font-[Outfit]">Premium Editor</h1>
      <p class="text-slate-500">
        Type <code class="bg-white border border-slate-200 px-1.5 py-0.5 rounded text-sm mx-1 shadow-sm">/</code> to
        browse commands
      </p>
    </div>

    <!-- Editor Container -->
    <div class="bg-white border border-slate-200 rounded-2xl shadow-xl overflow-hidden min-h-[80vh] mx-4 relative">
      <div id="editor"></div>
    </div>

    <div
      class="mt-8 bg-slate-100 rounded-lg p-4 mx-4 text-xs font-mono text-slate-600 overflow-auto max-h-96 w-full max-w-5xl">
      <div class="font-bold mb-2">Debug JSON:</div>
      <pre id="debug-json">{}</pre>
    </div>
  </div>

  <!-- Table Controls (Bubble Menu Container) -->
  <div id="table-bubble-menu" class="hidden">
    <!-- Buttons injected by JS -->
  </div>

  <!-- AI Bubble Menu -->
  <div id="ai-bubble-menu"
    class="hidden flex items-center gap-1 bg-white border border-slate-200 rounded-lg shadow-lg p-1">
    <button data-action="improve"
      class="ai-btn flex items-center gap-2 px-2 py-1 text-sm text-slate-600 hover:bg-slate-100 rounded">
      <span>‚ú®</span> Improve
    </button>
    <button data-action="summarize"
      class="ai-btn flex items-center gap-2 px-2 py-1 text-sm text-slate-600 hover:bg-slate-100 rounded">
      <span>üìù</span> Summarize
    </button>
    <button data-action="explain"
      class="ai-btn flex items-center gap-2 px-2 py-1 text-sm text-slate-600 hover:bg-slate-100 rounded">
      <span>ü§î</span> Explain
    </button>
    <button data-action="continue"
      class="ai-btn flex items-center gap-2 px-2 py-1 text-sm text-slate-600 hover:bg-slate-100 rounded">
      <span>‚û°Ô∏è</span> Continue
    </button>
    <div id="ai-loader" class="hidden ml-2">
      <div class="animate-spin h-4 w-4 border-2 border-blue-500 border-t-transparent rounded-full"></div>
    </div>
  </div>

  <!-- Universal Modal -->
  <div id="ui-modal" class="modal-overlay">
    <div class="modal-card">
      <h3 id="modal-title" class="modal-title">Insert Content</h3>
      <input type="text" id="modal-input" class="modal-input" placeholder="https://..." />
      <div class="modal-actions">
        <button id="modal-cancel" class="btn btn-secondary">Cancel</button>
        <button id="modal-confirm" class="btn btn-primary">Insert</button>
      </div>
    </div>
  </div>
  </div>

  <!-- Loading Overlay -->
  <div id="loading-overlay" class="modal-overlay" style="z-index: 200;">
    <div class="bg-white p-6 rounded-lg shadow-xl flex flex-col items-center">
      <div class="animate-spin rounded-full h-10 w-10 border-b-2 border-blue-600 mb-4"></div>
      <p class="text-slate-600 font-medium">Uploading...</p>
    </div>
  </div>

  <!-- AI Preview Overlay -->
  <div id="ai-preview-overlay"
    class="hidden fixed bottom-10 left-1/2 transform -translate-x-1/2 bg-white border border-slate-200 shadow-2xl rounded-xl w-[600px] max-w-[90vw] z-50 flex flex-col overflow-hidden">
    <div class="bg-slate-50 px-4 py-2 border-b border-slate-100 flex justify-between items-center">
      <span class="text-xs font-semibold text-slate-500 uppercase tracking-wider">AI Preview</span>
      <div class="flex gap-2">
        <span id="ai-status" class="text-xs text-blue-500 animate-pulse">Generative...</span>
      </div>
    </div>
    <div id="ai-preview-content" class="p-6 max-h-[60vh] overflow-y-auto prose prose-sm">
      <!-- AI Content Stream -->
    </div>
    <div class="p-3 bg-slate-50 border-t border-slate-100 flex justify-end gap-2">
      <button id="ai-reject"
        class="px-3 py-1.5 text-sm text-slate-600 hover:bg-slate-200 rounded-md transition-colors">Discard</button>
      <button id="ai-accept"
        class="px-3 py-1.5 text-sm bg-blue-600 text-white hover:bg-blue-700 rounded-md shadow-sm transition-colors">Accept</button>
    </div>
  </div>

  <script type="module">
    import { Editor, Node, mergeAttributes, Extension, InputRule, wrappingInputRule } from 'https://esm.sh/@tiptap/core@2.11.5?bundle';
    import Document from 'https://esm.sh/@tiptap/extension-document@2.11.5?bundle';
    import Paragraph from 'https://esm.sh/@tiptap/extension-paragraph@2.11.5?bundle';
    import Text from 'https://esm.sh/@tiptap/extension-text@2.11.5?bundle';
    import Blockquote from 'https://esm.sh/@tiptap/extension-blockquote@2.11.5?bundle';
    import BulletList from 'https://esm.sh/@tiptap/extension-bullet-list@2.11.5?bundle';
    import OrderedList from 'https://esm.sh/@tiptap/extension-ordered-list@2.11.5?bundle';
    import ListItem from 'https://esm.sh/@tiptap/extension-list-item@2.11.5?bundle';
    import HardBreak from 'https://esm.sh/@tiptap/extension-hard-break@2.11.5?bundle';
    import HorizontalRule from 'https://esm.sh/@tiptap/extension-horizontal-rule@2.11.5?bundle';
    import Heading from 'https://esm.sh/@tiptap/extension-heading@2.11.5?bundle';
    import Bold from 'https://esm.sh/@tiptap/extension-bold@2.11.5?bundle';
    import Code from 'https://esm.sh/@tiptap/extension-code@2.11.5?bundle';
    import Italic from 'https://esm.sh/@tiptap/extension-italic@2.11.5?bundle';
    import Strike from 'https://esm.sh/@tiptap/extension-strike@2.11.5?bundle';
    import Dropcursor from 'https://esm.sh/@tiptap/extension-dropcursor@2.11.5?bundle';
    import Gapcursor from 'https://esm.sh/@tiptap/extension-gapcursor@2.11.5?bundle';
    import History from 'https://esm.sh/@tiptap/extension-history@2.11.5?bundle';
    import Placeholder from 'https://esm.sh/@tiptap/extension-placeholder@2.11.5?bundle';
    import TaskList from 'https://esm.sh/@tiptap/extension-task-list@2.11.5?bundle';
    import TaskItem from 'https://esm.sh/@tiptap/extension-task-item@2.11.5?bundle';
    import Link from 'https://esm.sh/@tiptap/extension-link@2.11.5?bundle';
    import Image from 'https://esm.sh/@tiptap/extension-image@2.11.5?bundle';
    import Table from 'https://esm.sh/@tiptap/extension-table@2.11.5?bundle';
    import TableRow from 'https://esm.sh/@tiptap/extension-table-row@2.11.5?bundle';
    import TableCell from 'https://esm.sh/@tiptap/extension-table-cell@2.11.5?bundle';
    import TableHeader from 'https://esm.sh/@tiptap/extension-table-header@2.11.5?bundle';
    import Youtube from 'https://esm.sh/@tiptap/extension-youtube@2.11.5?bundle';
    import { BubbleMenu } from 'https://esm.sh/@tiptap/extension-bubble-menu@2.11.5?bundle';
    import CodeBlockLowlight from 'https://esm.sh/@tiptap/extension-code-block-lowlight@2.11.5?bundle';
    import { common, createLowlight } from 'https://esm.sh/lowlight?bundle';
    import katex from 'https://esm.sh/katex';
    import Suggestion from 'https://esm.sh/@tiptap/suggestion@2.11.5?bundle';
    import { Markdown } from 'https://esm.sh/tiptap-markdown@0.8.10?bundle';
    import { Plugin, PluginKey, NodeSelection, TextSelection } from 'https://esm.sh/prosemirror-state?bundle';
    import { DOMSerializer } from 'https://esm.sh/prosemirror-model?bundle';

    /* ====================== SECTION: CONFIG ====================== */
    const CONFIG = (() => {
      const GEMINI_API_KEY = '';
      const GEMINI_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;

      // Initialize Lowlight (Syntax Highlighting)
      const lowlight = createLowlight(common);

      const STORAGE_KEY = 'tiptap-premium-editor-content';

      const DEFAULT_CONTENT = {
        type: 'doc',
        content: [
          {
            type: 'heading',
            attrs: { level: 1 },
            content: [{ type: 'text', text: 'Premium Editor' }]
          },
          {
            type: 'paragraph',
            content: [
              { type: 'text', text: 'This is a polished TipTap editor with ' },
              { type: 'text', marks: [{ type: 'bold' }], text: 'Code highlighting' },
              { type: 'text', text: ', ' },
              { type: 'text', marks: [{ type: 'bold' }], text: 'Math' },
              { type: 'text', text: ' support, and better UI.' }
            ]
          },
          {
            type: 'codeBlock',
            attrs: { language: 'javascript' },
            content: [{ type: 'text', text: "console.log('Hello World');" }]
          },
          {
            type: 'callout',
            attrs: { type: 'info' },
            content: [{
              type: 'paragraph',
              content: [
                { type: 'text', text: 'Try typing ' },
                { type: 'text', marks: [{ type: 'code' }], text: '/' },
                { type: 'text', text: ' to see the grouped menu.' }
              ]
            }]
          }
        ]
      };

      return {
        GEMINI_URL,
        lowlight,
        STORAGE_KEY,
        DEFAULT_CONTENT
      };
    })();

    /* ====================== SECTION: UTILS ====================== */
    const UTILS = (() => {
      /* --- File Upload Helper --- */
      const triggerFileUpload = (accept) => {
        return new Promise((resolve) => {
          const input = document.createElement('input');
          input.type = 'file';
          input.accept = accept;
          input.onchange = (e) => {
            const file = e.target.files[0];
            if (file) {
              const loading = document.getElementById('loading-overlay');
              if (loading) loading.classList.add('active'); // Show loading

              const objectUrl = URL.createObjectURL(file);

              // Simulate a small network delay for realism/UX
              setTimeout(() => {
                if (loading) loading.classList.remove('active'); // Hide loading
                resolve({
                  src: objectUrl,
                  name: file.name,
                  size: file.size,
                  type: file.type
                });
              }, 600);
            } else {
              resolve(null);
            }
          };
          input.click();
        });
      };

      return { triggerFileUpload };
    })();

    /* ====================== SECTION: UI ====================== */
    const UI = (() => {
      const Modal = {
        overlay: document.getElementById('ui-modal'),
        title: document.getElementById('modal-title'),
        input: document.getElementById('modal-input'),
        confirm: document.getElementById('modal-confirm'),
        cancel: document.getElementById('modal-cancel'),
        resolve: null,

        open(title, placeholder = 'Enter URL...') {
          this.title.textContent = title;
          this.input.placeholder = placeholder;
          this.input.value = '';
          this.overlay.classList.add('active');
          this.input.focus();

          return new Promise((resolve) => {
            this.resolve = resolve;
          });
        },

        close() {
          this.overlay.classList.remove('active');
          this.resolve = null;
        }
      };

      Modal.confirm.onclick = () => {
        if (Modal.resolve) Modal.resolve(Modal.input.value);
        Modal.close();
      };

      Modal.cancel.onclick = () => {
        if (Modal.resolve) Modal.resolve(null);
        Modal.close();
      };

      Modal.input.onkeydown = (e) => {
        if (e.key === 'Enter') Modal.confirm.click();
        if (e.key === 'Escape') Modal.cancel.click();
      };

      // AI Preview Overlay System
      const aiUI = {
        overlay: document.getElementById('ai-preview-overlay'),
        content: document.getElementById('ai-preview-content'),
        status: document.getElementById('ai-status'),
        acceptBtn: document.getElementById('ai-accept'),
        rejectBtn: document.getElementById('ai-reject'),
        resolvePromise: null,

        show() {
          this.overlay.classList.remove('hidden');
          this.content.innerHTML = '';
          this.status.textContent = 'Thinking...';
          this.status.className = 'text-xs text-blue-500 animate-pulse';
          this.acceptBtn.disabled = true;
        },

        hide() {
          this.overlay.classList.add('hidden');
          this.resolvePromise = null;
        },

        updatePreview(html) {
          this.content.innerHTML = html;
          this.content.scrollTop = this.content.scrollHeight;
        },

        setSuccess() {
          this.status.textContent = 'Generated';
          this.status.className = 'text-xs text-green-600 font-bold';
          this.acceptBtn.disabled = false;
        },

        setError(msg) {
          this.status.textContent = 'Error';
          this.status.className = 'text-xs text-red-600 font-bold';
          this.content.innerHTML = `<p class="text-red-500">${msg}</p>`;
        },

        async waitForUser() {
          return new Promise((resolve) => {
            this.resolvePromise = resolve;
            this.acceptBtn.onclick = () => resolve(true);
            this.rejectBtn.onclick = () => resolve(false);
          });
        }
      };

      // Table Bubble Menu Helper
      const setupTableMenu = (editor) => {
        const tableMenuContainer = document.querySelector('#table-bubble-menu');
        if (tableMenuContainer) {
          tableMenuContainer.className = 'bubble-menu hidden';
          tableMenuContainer.innerHTML = ''; // Clear existing

          const createBtn = (icon, action, title, isDestructive = false) => {
            const btn = document.createElement('button');
            btn.className = `bubble-btn ${isDestructive ? 'text-red-500 hover:text-red-700 hover:bg-red-50' : ''}`;
            btn.innerHTML = icon;
            btn.title = title;
            // Check if action exists in chain? Actually we assume it does for table extension
            btn.onclick = () => editor.chain().focus()[action]().run();
            return btn;
          };

          tableMenuContainer.append(
            createBtn('‚Üê', 'addColumnBefore', 'Add Col Before'),
            createBtn('‚Üí', 'addColumnAfter', 'Add Col After'),
            createBtn('‚Üë', 'addRowBefore', 'Add Row Before'),
            createBtn('‚Üì', 'addRowAfter', 'Add Row After'),
            createBtn('üóëÔ∏è', 'deleteTable', 'Delete Table', true)
          );
        }
      };

      return { Modal, aiUI, setupTableMenu };
    })();

    /* ====================== SECTION: NODE_VIEWS ====================== */
    const NODE_VIEWS = (() => {

      const createResizable = (type) => {
        return ({ node, editor, getPos }) => {
          const container = document.createElement('div');
          container.classList.add('node-container'); // Helper class for hover
          container.style.position = 'relative';
          container.style.display = 'inline-block';
          container.style.maxWidth = '100%';
          container.style.margin = '1.5rem 0';
          container.style.lineHeight = '0';

          // Initial width
          container.style.width = node.attrs.width || '100%';

          const media = document.createElement(type === 'video' ? 'video' : 'img');
          if (type === 'video') {
            media.controls = true;
            // Prevent drag on video controls from conflicting?
          }
          media.style.borderRadius = '12px';
          media.src = node.attrs.src;
          media.style.width = '100%';
          media.style.height = 'auto';
          media.style.display = 'block';
          // media.draggable = false; // Let container handle selection

          const handle = document.createElement('div');
          handle.className = 'resize-handle';

          // Drag logic
          handle.addEventListener('mousedown', (e) => {
            e.preventDefault();
            e.stopPropagation(); // Stop editor selection
            const startX = e.clientX;
            const startWidth = container.offsetWidth;

            const onMouseMove = (e) => {
              const currentX = e.clientX;
              const diffX = currentX - startX;
              const newWidth = Math.max(100, startWidth + diffX);
              container.style.width = `${newWidth}px`;
            };

            const onMouseUp = () => {
              document.removeEventListener('mousemove', onMouseMove);
              document.removeEventListener('mouseup', onMouseUp);
              if (typeof getPos === 'function') {
                const pos = getPos();
                if (pos !== undefined && pos !== null) {
                  editor.commands.updateAttributes(pos, { width: container.style.width });
                }
              }
            };

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
          });

          container.append(media, handle);

          return {
            dom: container,
            update: (updatedNode) => {
              if (updatedNode.type.name !== (type === 'video' ? 'video' : 'image')) return false;
              if (updatedNode.attrs.src !== node.attrs.src) media.src = updatedNode.attrs.src;
              if (updatedNode.attrs.width !== node.attrs.width) container.style.width = updatedNode.attrs.width;
              node = updatedNode;
              return true;
            },
            selectNode: () => {
              container.classList.add('ProseMirror-selectednode');
              media.style.outline = '3px solid #3b82f6';
              media.style.outlineOffset = '2px';
            },
            deselectNode: () => {
              container.classList.remove('ProseMirror-selectednode');
              media.style.outline = 'none';
            }
          };
        }
      };

      const FileAttachmentView = ({ node }) => {
        const dom = document.createElement('a');
        dom.className = 'file-attachment';
        dom.href = node.attrs.src;
        dom.download = node.attrs.name;
        dom.contentEditable = 'false';

        const sizeKB = (node.attrs.size / 1024).toFixed(1);

        dom.innerHTML = `
        <div class="file-icon">üìé</div>
        <div class="file-info">
          <span class="file-name">${node.attrs.name}</span>
          <span class="file-size">${sizeKB} KB</span>
        </div>
      `;

        return { dom };
      };

      const MathBlockView = ({ node, getPos, editor }) => {
        const container = document.createElement('div');
        container.classList.add('math-block-container');

        const preview = document.createElement('div');
        preview.classList.add('math-preview');
        preview.title = 'Click to edit equation';

        const input = document.createElement('textarea');
        input.classList.add('math-input');
        input.value = node.attrs.text;
        input.placeholder = 'Type LaTeX equation (e.g. E = mc^2)';

        const renderMath = (text) => {
          preview.innerHTML = '';
          if (!text || text.trim() === '') {
            preview.textContent = 'Empty equation';
            preview.style.color = '#94a3b8';
            return;
          }
          try {
            katex.render(text, preview, {
              throwOnError: false,
              displayMode: true
            });
            preview.style.color = 'inherit';
          } catch (e) {
            preview.textContent = e.message;
            preview.style.color = '#ef4444';
          }
        };

        // Initial Render
        renderMath(node.attrs.text);

        // Interaction Logic
        let isEditing = false;

        const toggleEdit = (active) => {
          if (isEditing === active) return; // Debounce duplicate state changes
          isEditing = active;

          if (active) {
            container.classList.add('is-editing');
            // Small delay to ensure display:block applied before focus
            setTimeout(() => {
              input.focus();
            }, 10);
          } else {
            container.classList.remove('is-editing');
            // Save changes if dirty
            if (input.value !== node.attrs.text) {
              if (typeof getPos === 'function') {
                const pos = getPos();
                if (pos !== undefined && pos !== null) {
                  editor.chain().focus().command(({ tr }) => {
                    return tr.setNodeAttribute(pos, 'text', input.value);
                  }).run();
                }
              }
            }
          }
        };

        preview.addEventListener('click', (e) => {
          e.preventDefault();
          toggleEdit(true);
        });

        input.addEventListener('input', (e) => {
          // Just update preview locally, don't trigger transaction yet
          renderMath(e.target.value);
        });

        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            toggleEdit(false);
            editor.commands.focus(); // Return focus to editor
          }
        });

        // Handle blur - checks if focus moved outside the component
        input.addEventListener('blur', (e) => {
          // We use a timeout to allow clicks on other parts of UI to process first if needed
          // But simpler: just close.
          toggleEdit(false);
        });

        container.append(preview, input);

        return {
          dom: container,
          // Prevent ProtonMirror from re-rendering the node when we type in the textarea
          ignoreMutation: (mutation) => {
            // We handle our own mutations (textarea input)
            return true;
          },
          // Stop events from bubbling up to the editor to prevent unwanted side effects
          stopEvent: (event) => {
            // Allow default behavior for the textarea (keyboard interaction, etc.)
            if (event.target === input) {
              // For keydown, we want to stop propagation so Tiptap doesn't handle Enter/Backspace etc.
              // But for 'input', maybe not?
              // Generally returning true safely isolates the input.
              return true;
            }
            return false;
          },
          update: (updatedNode) => {
            if (updatedNode.type.name !== 'mathBlock') return false;
            // Sync local state if external update happened (e.g. Undo/Redo)
            if (updatedNode.attrs.text !== node.attrs.text) {
              node = updatedNode;
              input.value = node.attrs.text;
              renderMath(node.attrs.text);
            }
            return true;
          },
          selectNode: () => {
            container.classList.add('ProseMirror-selectednode');
          },
          deselectNode: () => {
            container.classList.remove('ProseMirror-selectednode');
            toggleEdit(false);
          }
        };
      };

      const CalloutView = ({ node, editor, getPos }) => {
        const dom = document.createElement('div');
        dom.classList.add('callout', `callout-${node.attrs.type}`);
        dom.style.position = 'relative';

        const icon = document.createElement('span');
        icon.className = 'callout-icon';
        icon.contentEditable = 'false';
        const getIcon = (t) => {
          if (t === 'success') return '‚úÖ';
          if (t === 'warning') return '‚ö†Ô∏è';
          if (t === 'error') return '‚õî';
          return 'üí°';
        };
        icon.innerText = getIcon(node.attrs.type);

        const content = document.createElement('div');
        content.className = 'callout-content';
        content.style.flex = '1';

        // Type Selector (Premium Feature)
        const select = document.createElement('select');
        select.className = 'callout-type-select';
        select.style.cssText = `
        position: absolute;
        top: 8px;
        right: 8px;
        font-size: 11px;
        padding: 2px 6px;
        border-radius: 4px;
        border: 1px solid rgba(0,0,0,0.1);
        background: rgba(255,255,255,0.8);
        opacity: 0;
        transition: opacity 0.2s;
        cursor: pointer;
        outline: none;
        color: #475569;
        font-weight: 600;
      `;
        ['info', 'success', 'warning', 'error'].forEach(t => {
          const opt = document.createElement('option');
          opt.value = t;
          opt.innerText = t.charAt(0).toUpperCase() + t.slice(1);
          if (node.attrs.type === t) opt.selected = true;
          select.appendChild(opt);
        });

        dom.onmouseenter = () => select.style.opacity = '1';
        dom.onmouseleave = () => select.style.opacity = '0';

        select.onchange = (e) => {
          if (typeof getPos === 'function') {
            editor.commands.updateAttributes(getPos(), { type: e.target.value });
          }
        };

        dom.append(icon, content, select);

        return {
          dom,
          contentDOM: content,
          update: (updatedNode) => {
            if (updatedNode.type.name !== 'callout') return false;
            if (updatedNode.attrs.type !== node.attrs.type) {
              dom.classList.remove(`callout-${node.attrs.type}`);
              dom.classList.add(`callout-${updatedNode.attrs.type}`);
              icon.innerText = getIcon(updatedNode.attrs.type);
              select.value = updatedNode.attrs.type;
            }
            node = updatedNode;
            return true;
          }
        };
      };

      const CodeBlockView = ({ node, editor, getPos, extension }) => {
        const dom = document.createElement('div');
        dom.style.position = 'relative';
        dom.className = 'code-block-wrapper';

        const select = document.createElement('select');
        select.className = 'language-selector';
        select.contentEditable = 'false';

        // Common languages
        const langs = ['javascript', 'css', 'html', 'python', 'java', 'cpp', 'typescript', 'json', 'bash', 'go', 'rust'];

        langs.forEach(lang => {
          const option = document.createElement('option');
          option.value = lang;
          option.innerText = lang;
          if (lang === node.attrs.language) option.selected = true;
          select.appendChild(option);
        });

        select.addEventListener('change', (e) => {
          if (typeof getPos === 'function') {
            editor.commands.updateAttributes(getPos(), { language: e.target.value });
          }
        });

        const pre = document.createElement('pre');
        const code = document.createElement('code');

        pre.append(code);
        dom.append(select, pre);

        return {
          dom,
          contentDOM: code,
          update: (updatedNode) => {
            if (updatedNode.type.name !== node.type.name) return false;
            if (updatedNode.attrs.language !== node.attrs.language) {
              select.value = updatedNode.attrs.language;
            }
            node = updatedNode;
            return true;
          }
        };
      };

      const McqView = ({ node, getPos, editor }) => {
        // 1. Container
        const dom = document.createElement('div');
        dom.classList.add('mcq-node');
        dom.setAttribute('role', 'group');
        dom.setAttribute('aria-label', 'Multiple Choice Question');
        dom.setAttribute('tabindex', '-1'); // Not focusable itself, children are
        dom.style.cssText = `
        border: 2px solid #e2e8f0;
        border-radius: 12px;
        padding: 1.5rem;
        background: #fff;
        margin: 2rem 0;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        transition: border-color 0.2s, box-shadow 0.2s;
        position: relative;
      `;

        // 2. Helper for Safe Updates
        const updateAttrs = (attrs) => {
          if (typeof getPos === 'function') {
            const pos = getPos();
            if (pos !== undefined && pos !== null) {
              editor.view.dispatch(
                editor.state.tr.setNodeMarkup(pos, undefined, {
                  ...node.attrs,
                  ...attrs,
                })
              );
            }
          }
        };

        // 3. Question Input
        const questionInput = document.createElement('input');
        questionInput.type = 'text';

        // Helper for Jumping Blocks
        const jumpForward = () => {
          editor.commands.focus();
          const { state } = editor;
          const { doc } = state;
          if (typeof getPos === 'function') {
            const nextPos = getPos() + node.nodeSize;
            if (nextPos < doc.content.size) {
              const nextSelection = TextSelection.near(doc.resolve(nextPos), 1);
              editor.view.dispatch(state.tr.setSelection(nextSelection));
              editor.view.focus();
            }
          }
        };

        const jumpBackward = () => {
          editor.commands.focus();
          if (typeof getPos === 'function') {
            const { state } = editor;
            const { doc } = state;
            const prevPos = getPos();
            if (prevPos > 0) {
              const prevSelection = TextSelection.near(doc.resolve(prevPos - 1), -1);
              editor.view.dispatch(state.tr.setSelection(prevSelection));
              editor.view.focus();
            }
          }
        };

        const handleBlockJump = (e) => {
          if ((e.ctrlKey || e.metaKey) && e.key === 'ArrowDown') {
            e.preventDefault();
            jumpForward();
          }
          if ((e.ctrlKey || e.metaKey) && e.key === 'ArrowUp') {
            e.preventDefault();
            jumpBackward();
          }
        };

        questionInput.addEventListener('keydown', handleBlockJump);
        questionInput.placeholder = 'Enter your question...';
        questionInput.value = node.attrs.question;
        questionInput.setAttribute('aria-label', 'Question');
        questionInput.setAttribute('tabindex', '0');
        questionInput.style.cssText = `
        width: 100%;
        font-family: inherit;
        font-size: 1.125rem;
        font-weight: 600;
        color: #1e293b;
        border: none;
        border-bottom: 2px solid #e2e8f0;
        padding: 0.5rem 0;
        margin-bottom: 1.5rem;
        background: transparent;
        outline: none;
        transition: border-color 0.2s;
      `;

        questionInput.oninput = (e) => updateAttrs({ question: e.target.value });
        questionInput.onfocus = () => { questionInput.style.borderBottomColor = '#3b82f6'; };
        questionInput.onblur = () => { questionInput.style.borderBottomColor = '#e2e8f0'; };

        // Question Input Keyboard Navigation
        questionInput.onkeydown = (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            // Move focus to first option input
            const firstOption = optionsCtx.querySelector('input');
            if (firstOption) firstOption.focus();
            else addBtn.focus();
          } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            const firstOption = optionsCtx.querySelector('input');
            if (firstOption) firstOption.focus();
          }
        };

        // 4. Options Container
        const optionsCtx = document.createElement('div');
        optionsCtx.style.cssText = 'display: flex; flex-direction: column; gap: 0.75rem;';
        optionsCtx.setAttribute('role', 'list');

        // 5. Render Logic
        const renderOptions = () => {
          optionsCtx.innerHTML = '';
          node.attrs.options.forEach((option, index) => {
            const row = document.createElement('div');
            row.setAttribute('role', 'listitem');
            row.style.cssText = 'display: flex; align-items: center; gap: 0.75rem; width: 100%;';

            // Correct Toggle
            const checkbox = document.createElement('div'); // Using div as custom checkbox for better control
            checkbox.setAttribute('role', 'checkbox');
            checkbox.setAttribute('aria-checked', option.isCorrect.toString());
            checkbox.setAttribute('aria-label', `Mark option ${index + 1} as correct`);
            checkbox.setAttribute('tabindex', '0');
            checkbox.style.cssText = `
            width: 24px;
            height: 24px;
            border-radius: 6px;
            border: 2px solid ${option.isCorrect ? '#22c55e' : '#cbd5e1'};
            background: ${option.isCorrect ? '#22c55e' : 'transparent'};
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            flex-shrink: 0;
            transition: all 0.2s;
          `;

            if (option.isCorrect) {
              checkbox.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
            }

            const toggleCorrect = () => {
              const newOptions = node.attrs.options.map((opt, i) => ({
                ...opt,
                isCorrect: i === index ? !opt.isCorrect : false
              }));
              updateAttrs({ options: newOptions });
              // Announce change
              const liveRegion = document.getElementById('editor-live-region');
              if (liveRegion) liveRegion.textContent = `Option ${index + 1} marked as ${!option.isCorrect ? 'correct' : 'incorrect'}`;
            };

            checkbox.onmousedown = (e) => { e.preventDefault(); toggleCorrect(); };
            checkbox.onkeydown = (e) => {
              if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                toggleCorrect();
              }
            };

            // Text Input
            const input = document.createElement('input');
            input.type = 'text';
            input.value = option.text;
            input.placeholder = `Option ${index + 1}`;
            input.addEventListener('keydown', handleBlockJump);
            input.setAttribute('aria-label', `Option ${index + 1} text`);
            input.style.cssText = `
            flex: 1;
            padding: 0.5rem 0.75rem;
            border: 1px solid ${option.isCorrect ? '#86efac' : '#e2e8f0'};
            border-radius: 0.5rem;
            font-size: 0.95rem;
            color: #334155;
            outline: none;
            transition: all 0.2s;
            background: ${option.isCorrect ? '#f0fdf4' : 'transparent'};
          `;

            input.oninput = (e) => {
              const newOptions = [...node.attrs.options];
              newOptions[index] = { ...newOptions[index], text: e.target.value };
              updateAttrs({ options: newOptions });
            };

            input.onfocus = () => { if (!option.isCorrect) input.style.borderColor = '#3b82f6'; };
            input.onblur = () => { if (!option.isCorrect) input.style.borderColor = '#e2e8f0'; };

            // Input Keyboard Nav
            input.onkeydown = (e) => {
              if (e.key === 'Enter') {
                e.preventDefault();
                // Add new option below
                const newId = Math.random().toString(36).slice(2, 9);
                const newOptions = [...node.attrs.options];
                newOptions.splice(index + 1, 0, { id: newId, text: '', isCorrect: false });
                updateAttrs({ options: newOptions });
                // Focus logic will need to handle update - handled in update() or forced delayed focus
                setTimeout(() => {
                  const inputs = optionsCtx.querySelectorAll('input[type="text"]');
                  if (inputs[index + 1]) inputs[index + 1].focus();
                }, 50);
              } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                const inputs = optionsCtx.querySelectorAll('input[type="text"]');
                if (inputs[index + 1]) inputs[index + 1].focus();
                else addBtn.focus();
              } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                const inputs = optionsCtx.querySelectorAll('input[type="text"]');
                if (inputs[index - 1]) inputs[index - 1].focus();
                else questionInput.focus();
              } else if (e.key === 'Backspace' && input.value === '' && node.attrs.options.length > 2) {
                // Delete option if empty (and not the only ones)
                e.preventDefault();
                const newOptions = node.attrs.options.filter((_, i) => i !== index);
                updateAttrs({ options: newOptions });
                setTimeout(() => {
                  const inputs = optionsCtx.querySelectorAll('input[type="text"]');
                  if (inputs[index - 1]) inputs[index - 1].focus();
                  else if (inputs[index]) inputs[index].focus();
                }, 50);
              }
            };

            // Delete Button
            const del = document.createElement('button');
            del.innerHTML = '√ó';
            del.setAttribute('aria-label', `Delete option ${index + 1}`);
            del.setAttribute('tabindex', '0');
            del.style.cssText = `
              width: 24px;
              height: 24px;
              display: flex;
              align-items: center;
              justify-content: center;
              border: none;
              background: transparent;
              color: #94a3b8;
              cursor: pointer;
              font-size: 20px;
              border-radius: 4px;
              transition: color 0.2s;
              line-height: 1;
              padding: 0;
          `;
            del.onmouseenter = () => del.style.color = '#ef4444';
            del.onmouseleave = () => del.style.color = '#94a3b8';

            const deleteOption = () => {
              const newOptions = node.attrs.options.filter((_, i) => i !== index);
              updateAttrs({ options: newOptions });
            };

            del.onmousedown = (e) => { e.preventDefault(); deleteOption(); };
            del.onkeydown = (e) => {
              if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                deleteOption();
              }
            };

            row.append(checkbox, input, del);
            optionsCtx.appendChild(row);
          });
        };

        renderOptions();

        // 6. Add Button
        const addBtn = document.createElement('button');
        addBtn.innerHTML = '+ Add Option';
        addBtn.addEventListener('keydown', handleBlockJump);
        addBtn.setAttribute('aria-label', 'Add new option');
        addBtn.style.cssText = `
        margin-top: 1rem;
        padding: 0.5rem 1rem;
        background: #f8fafc;
        border: 1px solid #e2e8f0;
        border-radius: 0.5rem;
        color: #475569;
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
      `;
        addBtn.onmouseenter = () => { addBtn.style.background = '#f1f5f9'; addBtn.style.color = '#1e293b'; };
        addBtn.onmouseleave = () => { addBtn.style.background = '#f8fafc'; addBtn.style.color = '#475569'; };

        const addOption = () => {
          const newId = Math.random().toString(36).slice(2, 9);
          const newOptions = [...node.attrs.options, { id: newId, text: '', isCorrect: false }];
          updateAttrs({ options: newOptions });
          // Focus new option
          setTimeout(() => {
            const inputs = optionsCtx.querySelectorAll('input[type="text"]');
            if (inputs[inputs.length - 1]) inputs[inputs.length - 1].focus();
          }, 50);
        };

        addBtn.onmousedown = (e) => { e.preventDefault(); addOption(); };
        addBtn.onkeydown = (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            addOption();
          } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            const inputs = optionsCtx.querySelectorAll('input[type="text"]');
            if (inputs.length > 0) inputs[inputs.length - 1].focus();
          }
        };

        dom.append(questionInput, optionsCtx, addBtn);

        return {
          dom,
          ignoreMutation: (mutation) => {
            if (dom.contains(mutation.target)) return true;
            return false;
          },
          stopEvent: (event) => {
            if (['INPUT', 'BUTTON', 'TEXTAREA'].includes(event.target.tagName)) {
              return true;
            }
            if (event.type === 'dragstart' && event.target === dom) return false;
            return false;
          },
          update: (updatedNode) => {
            if (updatedNode.type.name !== 'mcq') return false;

            // Question Sync
            if (updatedNode.attrs.question !== node.attrs.question) {
              questionInput.value = updatedNode.attrs.question;
            }

            // Options Sync
            if (updatedNode.attrs.options.length !== node.attrs.options.length) {
              node = updatedNode; // Update reference
              renderOptions();
            } else {
              const oldOpts = node.attrs.options;
              const newOpts = updatedNode.attrs.options;
              let needsRender = false;

              for (let i = 0; i < oldOpts.length; i++) {
                if (oldOpts[i].isCorrect !== newOpts[i].isCorrect) {
                  needsRender = true;
                  break;
                }
              }

              if (needsRender) {
                node = updatedNode;
                renderOptions();
              } else {
                node = updatedNode;
              }
            }
            return true;
          },
          selectNode: () => {
            dom.style.borderColor = '#3b82f6';
            dom.style.boxShadow = '0 0 0 3px rgba(59, 130, 246, 0.1)';
            const { state } = editor;
            const { selection } = state;
            if (selection instanceof NodeSelection && selection.node === node) {
              setTimeout(() => {
                if (questionInput) questionInput.focus();
              }, 10);
            }
          },
          deselectNode: () => {
            dom.style.borderColor = '#e2e8f0';
            dom.style.boxShadow = '0 4px 6px -1px rgba(0, 0, 0, 0.1)';
          }
        };
      };

      return { createResizable, MathBlockView, CalloutView, CodeBlockView, McqView, FileAttachmentView };

    })();

    /* ====================== SECTION: NODES ====================== */
    const NODES = (() => {

      const Video = Node.create({
        name: 'video',
        group: 'block',
        selectable: true,
        draggable: true,
        atom: true,

        addAttributes() {
          return {
            src: { default: null },
            width: { default: '100%' }
          }
        },

        parseHTML() {
          return [{ tag: 'video' }]
        },

        renderHTML({ HTMLAttributes }) {
          return ['video', mergeAttributes(HTMLAttributes, { controls: 'true', style: `width: ${HTMLAttributes.width}` })]
        },

        addNodeView() {
          return NODE_VIEWS.createResizable('video');
        }
      });

      const CustomImage = Image.extend({
        addAttributes() {
          const parentAttrs = this.parent ? this.parent() : {};
          return {
            ...parentAttrs,
            width: { default: '100%' }
          }
        },
        addNodeView() {
          return NODE_VIEWS.createResizable('image');
        }
      });

      const FileAttachment = Node.create({
        name: 'fileAttachment',
        group: 'block',
        atom: true,

        addAttributes() {
          return {
            src: { default: null },
            name: { default: 'file' },
            size: { default: 0 }
          }
        },

        parseHTML() {
          return [{ tag: 'div[data-type="file-attachment"]' }]
        },

        renderHTML({ HTMLAttributes }) {
          return ['div', mergeAttributes(HTMLAttributes, { 'data-type': 'file-attachment' })]
        },

        addNodeView() {
          return NODE_VIEWS.FileAttachmentView;
        }
      });

      const MathBlock = Node.create({
        name: 'mathBlock',
        group: 'block',
        atom: true,

        addAttributes() {
          return {
            text: {
              default: 'E = mc^2',
              parseHTML: element => element.getAttribute('data-text'),
              renderHTML: attributes => ({ 'data-text': attributes.text }),
            }
          }
        },

        parseHTML() {
          return [{
            tag: 'div[data-type="math-block"]',
            getAttrs: dom => ({ text: dom.getAttribute('data-text') })
          }]
        },

        renderHTML({ HTMLAttributes }) {
          return ['div', mergeAttributes(HTMLAttributes, { 'data-type': 'math-block' })]
        },

        addStorage() {
          return {
            markdown: {
              serialize: (state, node) => {
                state.write(`$$\n${node.attrs.text}\n$$`);
                state.closeBlock(node);
              }
            }
          }
        },

        addInputRules() {
          return [
            new InputRule({
              find: /^\$\$\s$/,
              handler: ({ state, range }) => {
                const { tr } = state;
                tr.replaceWith(range.from, range.to, this.type.create());
              }
            }),
          ]
        },

        addNodeView() {
          return NODE_VIEWS.MathBlockView;
        }
      });

      const Callout = Node.create({
        name: 'callout',
        group: 'block',
        content: 'block+',
        draggable: true,
        addAttributes() {
          return {
            type: { default: 'info' }
          }
        },
        addInputRules() {
          return [
            wrappingInputRule({ find: /^! $/, type: this.type }),
            wrappingInputRule({ find: /^!info $/, type: this.type, getAttributes: () => ({ type: 'info' }) }),
            wrappingInputRule({ find: /^!success $/, type: this.type, getAttributes: () => ({ type: 'success' }) }),
            wrappingInputRule({ find: /^!warning $/, type: this.type, getAttributes: () => ({ type: 'warning' }) }),
            wrappingInputRule({ find: /^!error $/, type: this.type, getAttributes: () => ({ type: 'error' }) }),
          ]
        },
        addKeyboardShortcuts() {
          return {
            'Enter': ({ editor }) => {
              if (!editor.isActive('callout')) return false;
              const { selection } = editor.state;
              if (selection.$from.parent.content.size === 0) return editor.commands.lift('callout');
              return false;
            },
            'Backspace': ({ editor }) => {
              if (!editor.isActive('callout')) return false;
              const { selection } = editor.state;
              if (selection.empty && selection.$from.parentOffset === 0 && selection.$from.parent.content.size === 0) {
                return editor.commands.lift('callout');
              }
              return false;
            },
          }
        },
        addNodeView() {
          return NODE_VIEWS.CalloutView;
        },
        addStorage() {
          return {
            markdown: {
              serialize: (state, node) => {
                state.write(`> [!${node.attrs.type || 'info'}]\n`);
                state.renderContent(node);
              }
            }
          }
        },
        parseHTML() {
          return [{ tag: 'div[data-type="callout"]', contentElement: '.callout-content' }]
        },
        renderHTML({ HTMLAttributes }) {
          return ['div', mergeAttributes(HTMLAttributes, { class: `callout callout-${HTMLAttributes.type}`, 'data-type': 'callout' }),
            ['div', { class: 'callout-content' }, 0]
          ]
        }
      });

      const PageBreak = Node.create({
        name: 'pageBreak',
        group: 'block',
        atom: true,
        parseHTML() { return [{ tag: 'div.page-break' }] },
        renderHTML({ HTMLAttributes }) {
          return ['div', mergeAttributes(HTMLAttributes, { class: 'page-break' })]
        }
      });

      const CustomCodeBlock = CodeBlockLowlight.extend({
        addNodeView() {
          return NODE_VIEWS.CodeBlockView;
        }
      });

      const Mcq = Node.create({
        name: 'mcq',
        group: 'block',
        atom: true,
        draggable: true,
        selectable: true,

        addAttributes() {
          return {
            question: {
              default: '',
            },
            options: {
              default: [
                { id: '1', text: 'Option 1', isCorrect: false },
                { id: '2', text: 'Option 2', isCorrect: false },
              ],
            }
          }
        },
        addStorage() {
          return {
            markdown: {
              serialize: (state, node) => {
                state.write(`? ${node.attrs.question}\n`);
                node.attrs.options.forEach(opt => {
                  state.write(`${opt.isCorrect ? '(x)' : '( )'} ${opt.text}\n`);
                });
                state.closeBlock(node);
              }
            }
          }
        },
        addInputRules() {
          return [
            new InputRule({
              find: /^\? $/,
              handler: ({ state, range }) => {
                const { tr } = state;
                tr.replaceWith(range.from, range.to, this.type.create());
              }
            }),
          ]
        },

        parseHTML() {
          return [
            {
              tag: 'div[data-type="mcq"]',
            },
          ]
        },

        renderHTML({ HTMLAttributes }) {
          return ['div', mergeAttributes(HTMLAttributes, { 'data-type': 'mcq' })]
        },

        addNodeView() {
          return NODE_VIEWS.McqView;
        }
      });

      return { Video, CustomImage, FileAttachment, MathBlock, Callout, PageBreak, CustomCodeBlock, Mcq };
    })();

    /* ====================== SECTION: PLUGINS ====================== */
    const PLUGINS = (() => {

      const GlobalShortcuts = Extension.create({
        name: 'globalShortcuts',
        addKeyboardShortcuts() {
          return {
            // Text Formatting
            'Mod-b': () => this.editor.commands.toggleBold(),
            'Mod-i': () => this.editor.commands.toggleItalic(),
            'Mod-Shift-s': () => this.editor.commands.toggleStrike(),
            'Mod-e': () => this.editor.commands.toggleCode(),
            'Ctrl-Alt-1': () => this.editor.commands.toggleHeading({ level: 1 }),
            'Ctrl-Alt-2': () => this.editor.commands.toggleHeading({ level: 2 }),
            'Ctrl-Alt-3': () => this.editor.commands.toggleHeading({ level: 3 }),
            'Mod-Shift-8': () => this.editor.commands.toggleBulletList(),
            'Mod-Shift-7': () => this.editor.commands.toggleOrderedList(),
            'Mod-Shift-9': () => this.editor.commands.toggleTaskList(),
            'Mod-Shift-h': () => this.editor.commands.setHorizontalRule(),

            // Block Insertion
            'Ctrl-Alt-m': () => {
              this.editor.chain().focus().insertContent({ type: 'mcq', attrs: { question: '' } }).run();
              return true;
            },
            'Ctrl-Alt-e': () => this.editor.chain().focus().insertContent({ type: 'mathBlock', attrs: { text: '' } }).run(),
            'Ctrl-Alt-c': () => this.editor.chain().focus().toggleCodeBlock().run(),
            'Ctrl-Alt-t': () => this.editor.chain().focus().insertTable({ rows: 3, cols: 3, withHeaderRow: true }).run(),
            'Ctrl-Alt-i': () => this.editor.chain().focus().insertContent({ type: 'callout', attrs: { type: 'info' }, content: [{ type: 'paragraph' }] }).run(),
            'Ctrl-Alt-p': () => this.editor.chain().focus().insertContent({ type: 'pageBreak' }).run(),

            // AI Actions
            'Ctrl-Shift-i': () => { AI.handleRequest('improve'); return true; },
            'Ctrl-Shift-u': () => { AI.handleRequest('summarize'); return true; },
            'Ctrl-Shift-x': () => { AI.handleRequest('explain'); return true; },
            'Ctrl-Shift-Enter': () => { AI.handleRequest('continue'); return true; },
            'Ctrl-Shift-m': () => { AI.handleRequest('generate-mcq'); return true; },
            'Ctrl-Shift-g': () => { AI.handleRequest('fix-grammar'); return true; },
          }
        }
      });

      const slashGroups = [
        {
          title: 'Text',
          items: [
            { title: 'Paragraph', icon: 'T', action: editor => editor.chain().focus().setParagraph().run() },
            { title: 'Heading 1', icon: 'H1', shortcut: 'Ctrl+Alt+1', action: editor => editor.chain().focus().toggleHeading({ level: 1 }).run() },
            { title: 'Heading 2', icon: 'H2', shortcut: 'Ctrl+Alt+2', action: editor => editor.chain().focus().toggleHeading({ level: 2 }).run() },
            { title: 'Heading 3', icon: 'H3', shortcut: 'Ctrl+Alt+3', action: editor => editor.chain().focus().toggleHeading({ level: 3 }).run() },
            { title: 'Bullet List', icon: '‚Ä¢', shortcut: 'Ctrl+Shift+8', action: editor => editor.chain().focus().toggleBulletList().run() },
            { title: 'Numbered List', icon: '1.', shortcut: 'Ctrl+Shift+7', action: editor => editor.chain().focus().toggleOrderedList().run() },
          ]
        },
        {
          title: 'Media',
          items: [
            {
              title: 'Image',
              description: 'Upload an image',
              icon: 'üñºÔ∏è',
              action: async (editor) => {
                const file = await UTILS.triggerFileUpload('image/*');
                if (file) editor.chain().focus().setImage({ src: file.src }).run();
              }
            },
            {
              title: 'Video',
              description: 'Upload a video',
              icon: 'üìπ',
              action: async (editor) => {
                const file = await UTILS.triggerFileUpload('video/*');
                if (file) editor.chain().focus().insertContent({ type: 'video', attrs: { src: file.src } }).run();
              }
            },
            {
              title: 'File',
              description: 'Upload a file attachment',
              icon: 'üìé',
              action: async (editor) => {
                const file = await UTILS.triggerFileUpload('*/*');
                if (file) editor.chain().focus().insertContent({ type: 'fileAttachment', attrs: { src: file.src, name: file.name, size: file.size } }).run();
              }
            },
            {
              title: 'Embed URL',
              description: 'YouTube, Link, etc.',
              icon: 'üîó',
              action: async (editor) => {
                const url = await UI.Modal.open('Insert Content', 'https://...');
                if (url) {
                  if (url.includes('youtube.com') || url.includes('youtu.be')) {
                    editor.chain().focus().setYoutube({ src: url }).run();
                  } else {
                    editor.chain().focus().extendMarkRange('link').setLink({ href: url }).run();
                  }
                }
              }
            }
          ]
        },
        {
          title: 'AI Actions',
          items: [
            {
              title: 'Write with AI',
              description: 'Generate structured educational content',
              icon: '‚úçÔ∏è',
              action: editor => AI.handleRequest('write')
            },
            { title: 'Continue', icon: '‚û°Ô∏è', shortcut: 'Ctrl+Shift+Ent', action: editor => AI.handleRequest('continue') },
            { title: 'Improve Writing', icon: '‚ú®', shortcut: 'Ctrl+Shift+I', action: editor => AI.handleRequest('improve') },
            { title: 'Summarize', icon: 'üìù', shortcut: 'Ctrl+Shift+U', action: editor => AI.handleRequest('summarize') },
            { title: 'Explain', icon: 'ü§î', shortcut: 'Ctrl+Shift+X', action: editor => AI.handleRequest('explain') },
            { title: 'Make Notes', icon: 'üìå', action: editor => AI.handleRequest('convert-to-notes') },
            { title: 'Generate MCQ', icon: '‚ùì', shortcut: 'Ctrl+Shift+M', action: editor => AI.handleRequest('generate-mcq') },
            { title: 'Fix Grammar', icon: 'abc', shortcut: 'Ctrl+Shift+G', action: editor => AI.handleRequest('fix-grammar') },
            { title: 'Change Tone (Formal)', icon: 'üëî', action: editor => AI.handleRequest('rewrite-tone', 'Formal') },
          ]
        },
        {
          title: 'Blocks',
          items: [
            { title: 'Mcq', description: 'Insert an MCQ block', icon: 'üìù', shortcut: 'Ctrl+Alt+M', action: editor => editor.chain().focus().insertContent({ type: 'mcq', attrs: { question: 'Enter your question here?' } }).run() },
            { title: 'Table', icon: '‚ñ¶', shortcut: 'Ctrl+Alt+T', action: editor => editor.chain().focus().insertTable({ rows: 3, cols: 3, withHeaderRow: true }).run() },
            { title: 'Code Block', icon: '{ }', shortcut: 'Ctrl+Alt+C', action: editor => editor.chain().focus().toggleCodeBlock().run() },
            { title: 'Math Equation', description: 'Insert a block equation (LaTeX)', icon: '‚àë', shortcut: 'Ctrl+Alt+E', action: editor => editor.chain().focus().insertContent({ type: 'mathBlock', attrs: { text: 'E = mc^2' } }).run() },
            { title: 'Info Callout', icon: 'üí°', shortcut: 'Ctrl+Alt+I', action: editor => editor.chain().focus().insertContent({ type: 'callout', attrs: { type: 'info' }, content: [{ type: 'paragraph', content: [{ type: 'text', text: 'Enter information here...' }] }] }).run() },
            { title: 'Success Callout', icon: '‚úÖ', action: editor => editor.chain().focus().insertContent({ type: 'callout', attrs: { type: 'success' }, content: [{ type: 'paragraph', content: [{ type: 'text', text: 'Task completed successfully!' }] }] }).run() },
            { title: 'Warning Callout', icon: '‚ö†Ô∏è', action: editor => editor.chain().focus().insertContent({ type: 'callout', attrs: { type: 'warning' }, content: [{ type: 'paragraph', content: [{ type: 'text', text: 'Please be careful with this action.' }] }] }).run() },
            { title: 'Error Callout', icon: '‚õî', action: editor => editor.chain().focus().insertContent({ type: 'callout', attrs: { type: 'error' }, content: [{ type: 'paragraph', content: [{ type: 'text', text: 'An error occurred. Please check your input.' }] }] }).run() },
            { title: 'Page Break', icon: '‚úÇÔ∏è', shortcut: 'Ctrl+Alt+P', action: editor => editor.chain().focus().insertContent({ type: 'pageBreak' }).run() }
          ]
        },
        {
          title: 'Utilities',
          items: [
            { title: 'Date', icon: 'üìÖ', action: editor => editor.chain().focus().insertContent(new Date().toLocaleDateString()).run() },
            { title: 'Time', icon: '‚è∞', action: editor => editor.chain().focus().insertContent(new Date().toLocaleTimeString()).run() },
            { title: 'Date & Time', icon: 'üìÜ', action: editor => editor.chain().focus().insertContent(new Date().toLocaleString()).run() },
            { title: 'Task List', icon: '‚òëÔ∏è', shortcut: 'Ctrl+Shift+9', action: editor => editor.chain().focus().toggleTaskList().run() },
            { title: 'Divider', icon: '‚Äî', shortcut: 'Ctrl+Shift+H', action: editor => editor.chain().focus().setHorizontalRule().run() },
          ]
        }
      ];

      const SlashCommand = Extension.create({
        name: 'slashCommand',
        addProseMirrorPlugins() {
          return [
            Suggestion({
              editor: this.editor,
              char: '/',
              startOfLine: false,
              items: ({ query }) => {
                return slashGroups.map(group => ({
                  title: group.title,
                  items: group.items.filter(item => item.title.toLowerCase().includes(query.toLowerCase()))
                })).filter(group => group.items.length > 0);
              },
              render: () => {
                let popup;
                let selectedIndex = 0;
                let suggestionProps;
                let domNodes = [];

                const renderList = () => {
                  if (!popup) return;
                  popup.innerHTML = '';
                  domNodes = [];

                  if (suggestionProps.items.length === 0) {
                    popup.style.display = 'none';
                    return;
                  }
                  popup.style.display = 'block';

                  suggestionProps.items.forEach(group => {
                    const groupTitle = document.createElement('div');
                    groupTitle.className = 'slash-group-title';
                    groupTitle.textContent = group.title;
                    popup.appendChild(groupTitle);

                    group.items.forEach((item, index) => {
                      const el = document.createElement('div');
                      el.className = 'slash-item';
                      el.role = 'option';
                      el.setAttribute('tabindex', '-1');
                      if (item.shortcut) {
                        el.setAttribute('aria-keyshortcuts', item.shortcut);
                      }

                      const shortcutHtml = item.shortcut ? `<span class="slash-item-shortcut" style="margin-left: auto; font-size: 10px; opacity: 0.6; color: inherit;">${item.shortcut}</span>` : '';

                      el.innerHTML = `
                    <div class="slash-item-icon">${item.icon}</div>
                    <div class="slash-item-content">
                      <div class="slash-item-title">${item.title}</div>
                      ${item.description ? `<div class="slash-item-desc">${item.description}</div>` : ''}
                    </div>
                    ${shortcutHtml}
                  `;

                      el.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        execute(item);
                      });

                      popup.appendChild(el);
                      domNodes.push({ el, item });
                    });
                  });
                };

                const updateSelection = (scroll = false) => {
                  domNodes.forEach(({ el }, index) => {
                    if (index === selectedIndex) {
                      el.classList.add('is-selected');
                      if (scroll) {
                        el.scrollIntoView({ block: 'nearest', inline: 'nearest' });
                      }
                    } else {
                      el.classList.remove('is-selected');
                    }
                  });
                };

                const execute = (item) => {
                  if (suggestionProps) {
                    const { editor, range } = suggestionProps;
                    editor.chain().focus().deleteRange(range).run();
                    item.action(editor);
                  }
                };

                const updatePosition = () => {
                  const rect = suggestionProps.clientRect();
                  if (rect) {
                    popup.style.position = 'absolute';
                    popup.style.top = (rect.bottom + window.scrollY + 10) + 'px';
                    popup.style.left = rect.left + 'px';
                  }
                };

                return {
                  onStart: props => {
                    suggestionProps = props;
                    popup = document.createElement('div');
                    popup.className = 'slash-popup';
                    document.body.appendChild(popup);
                    selectedIndex = 0;
                    renderList();
                    updateSelection(false);
                    updatePosition();
                  },
                  onUpdate(props) {
                    suggestionProps = props;
                    selectedIndex = 0;
                    renderList();
                    updateSelection(false);
                    updatePosition();
                  },
                  onKeyDown(props) {
                    if (props.event.key === 'Escape') {
                      popup.remove();
                      return true;
                    }
                    if (props.event.key === 'ArrowUp' || (props.event.key === 'Tab' && props.event.shiftKey)) {
                      selectedIndex = (selectedIndex + domNodes.length - 1) % domNodes.length;
                      updateSelection(true);
                      return true;
                    }
                    if (props.event.key === 'ArrowDown' || (props.event.key === 'Tab' && !props.event.shiftKey)) {
                      selectedIndex = (selectedIndex + 1) % domNodes.length;
                      updateSelection(true);
                      return true;
                    }
                    if (props.event.key === 'Enter') {
                      if (domNodes[selectedIndex]) {
                        execute(domNodes[selectedIndex].item);
                      }
                      return true;
                    }
                    return false;
                  },
                  onExit() {
                    if (popup) popup.remove();
                    popup = null;
                    domNodes = [];
                  }
                };
              }
            })
          ];
        }
      });

      const PremiumDragHandle = Extension.create({
        name: 'premiumDragHandle',
        addProseMirrorPlugins() {
          return [
            new Plugin({
              key: new PluginKey('premiumDragHandle'),
              view(editorView) {
                const handle = document.createElement('div');
                handle.className = 'global-drag-handle';
                handle.draggable = true;
                document.body.appendChild(handle);

                let currentBlock = null;
                let frameId = null;

                const hide = () => {
                  handle.classList.remove('visible');
                  currentBlock = null;
                };

                const updatePosition = (dom) => {
                  const rect = dom.getBoundingClientRect();
                  handle.style.top =
                    rect.top + window.scrollY + rect.height / 2 - 12 + 'px';
                  handle.style.left =
                    rect.left - 32 + 'px';
                  handle.classList.add('visible');
                };

                const onMouseMove = (e) => {
                  if (frameId) cancelAnimationFrame(frameId);
                  frameId = requestAnimationFrame(() => {
                    if (e.target === handle || handle.contains(e.target)) return;

                    const coords = { left: e.clientX, top: e.clientY };
                    const pos = editorView.posAtCoords(coords);

                    if (!pos) return hide();

                    let targetNode = null;
                    let targetPos = null;
                    let targetDom = null;

                    // 1. Check for Atom Block (MCQ, Image, etc.) directly at position
                    const directNode = editorView.state.doc.nodeAt(pos.pos);
                    if (directNode && directNode.isBlock && directNode.isAtom) {
                      targetNode = directNode;
                      targetPos = pos.pos;
                      targetDom = editorView.nodeDOM(targetPos);
                    }

                    // 2. If no atom found, traverse up from the resolved position
                    if (!targetNode) {
                      const $pos = editorView.state.doc.resolve(pos.pos);
                      for (let depth = $pos.depth; depth > 0; depth--) {
                        const node = $pos.node(depth);
                        if (node.isBlock && node.type.name !== 'doc') {
                          const parent = $pos.node(depth - 1);
                          if (parent && (parent.type.name === 'callout' || parent.type.name === 'listItem' || parent.type.name === 'mcq')) {
                            continue;
                          }
                          targetNode = node;
                          targetPos = $pos.before(depth);
                          targetDom = editorView.nodeDOM(targetPos);
                          break;
                        }
                      }
                    }

                    if (targetNode && targetDom && targetDom.nodeType === 1) {
                      const rect = targetDom.getBoundingClientRect();

                      if (e.clientX < rect.left - 50 || e.clientX > rect.left + rect.width) {
                      } else {
                        currentBlock = { pos: targetPos, dom: targetDom };
                        updatePosition(targetDom);
                        return;
                      }
                    }

                    // Safe zone check (keep visible if moving towards handle)
                    if (currentBlock) {
                      const rect = currentBlock.dom.getBoundingClientRect();
                      const handleRect = handle.getBoundingClientRect();

                      if (e.clientY >= rect.top - 20 && e.clientY <= rect.bottom + 20 &&
                        e.clientX >= handleRect.left - 20 && e.clientX <= rect.left + 50) {
                        return;
                      }
                    }

                    hide();
                  });
                };

                // Drag Start
                handle.addEventListener('dragstart', (e) => {
                  if (!currentBlock || !currentBlock.dom) {
                    e.preventDefault();
                    return;
                  }

                  const { pos, dom } = currentBlock;

                  try {
                    const tr = editorView.state.tr.setSelection(
                      NodeSelection.create(editorView.state.doc, pos)
                    );
                    editorView.dispatch(tr);
                  } catch (err) {
                    e.preventDefault();
                    return;
                  }

                  const slice = editorView.state.selection.content();
                  const serializer = DOMSerializer.fromSchema(editorView.state.schema);
                  const fragment = serializer.serializeFragment(slice.content);

                  const wrapper = document.createElement('div');
                  wrapper.appendChild(fragment);

                  if (e.dataTransfer) {
                    e.dataTransfer.setData('text/html', wrapper.innerHTML);
                    e.dataTransfer.setData('text/plain', wrapper.innerText || wrapper.textContent || '');
                    e.dataTransfer.effectAllowed = 'copyMove';
                    e.dataTransfer.setDragImage(dom, 0, 0);
                  }
                  editorView.dragging = { slice, move: true };
                });

                handle.addEventListener('drag', (e) => {
                  if (e.clientY === 0 && e.clientX === 0) return;
                  const y = e.clientY;
                  const h = window.innerHeight;
                  if (y < 50) {
                    window.scrollBy(0, -15);
                  } else if (y < 100) {
                    window.scrollBy(0, -5);
                  } else if (y > h - 50) {
                    window.scrollBy(0, 15);
                  } else if (y > h - 100) {
                    window.scrollBy(0, 5);
                  }
                });

                document.addEventListener('mousemove', onMouseMove);

                return {
                  destroy() {
                    handle.remove();
                    document.removeEventListener('mousemove', onMouseMove);
                  }
                };
              }
            })
          ];
        }
      });

      const CtrlArrowBlockJump = Extension.create({
        name: 'ctrlArrowBlockJump',
        addKeyboardShortcuts() {
          return {
            'Mod-ArrowDown': ({ editor }) => {
              const { state } = editor;
              const { selection, doc } = state;
              const { $from } = selection;
              const nextPos = $from.after();
              if (nextPos >= doc.content.size) return true;
              const nextSelection = TextSelection.near(doc.resolve(nextPos), 1);
              editor.view.dispatch(state.tr.setSelection(nextSelection));
              editor.view.focus();
              return true;
            },
            'Mod-ArrowUp': ({ editor }) => {
              const { state } = editor;
              const { selection, doc } = state;
              const { $from } = selection;
              const prevPos = $from.before();
              if (prevPos <= 0) return true;
              const prevSelection = TextSelection.near(doc.resolve(prevPos - 1), -1);
              editor.view.dispatch(state.tr.setSelection(prevSelection));
              editor.view.focus();
              return true;
            }
          };
        }
      });

      const convertCustomBlocksRobust = (editor) => {
        if (editor.isDestroyed) return;

        const { state } = editor;
        const updates = [];

        // 1. Math Block & Single-Node MCQ Detection
        state.doc.forEach((node, offset) => {
          if (node.type.name === 'paragraph') {
            const text = node.textContent.trim();

            // Math Block
            const rawFn = node.textContent.replace(/\n/g, '').trim();
            if (rawFn.startsWith('$$') && rawFn.endsWith('$$') && rawFn.length > 4) {
              const mathText = rawFn.slice(2, -2).trim();
              updates.push({
                from: offset,
                to: offset + node.nodeSize,
                type: 'mathBlock',
                attrs: { text: mathText }
              });
              return;
            }

            // Callout Block
            if (text.startsWith('! ') || text.startsWith('!info') || text.startsWith('!success') || text.startsWith('!warning') || text.startsWith('!error')) {
              const types = ['info', 'success', 'warning', 'error'];
              let detectedType = 'info';
              let contentStart = 0;

              for (const t of types) {
                if (text.startsWith(`!${t}`)) {
                  detectedType = t;
                  contentStart = t.length + 1;
                  break;
                }
              }

              if (text.startsWith('! ')) {
                detectedType = 'info';
                contentStart = 2;
              }

              const contentText = text.slice(contentStart).trim();

              updates.push({
                from: offset,
                to: offset + node.nodeSize,
                type: 'callout',
                attrs: { type: detectedType },
                content: contentText
              });
              return;
            }

            // Detect multiple inline math lines stacked
            if (/^(\$.*\$\n?)+$/.test(node.textContent.trim())) {
              const mathText = node.textContent.replace(/\$/g, '').trim();
              updates.push({
                from: offset,
                to: offset + node.nodeSize,
                type: 'mathBlock',
                attrs: { text: mathText }
              });
            }

            // Single-Paragraph MCQ
            const lines = text.split('\n').map(l => l.trim()).filter(l => l);
            if (lines.length >= 2 && lines[0].startsWith('? ')) {
              const question = lines[0].slice(2).trim();
              const options = [];

              for (let i = 1; i < lines.length; i++) {
                if (/^\(\s*[x\s]?\s*\)/.test(lines[i])) {
                  const isCorrect = /^\(\s*x\s*\)/i.test(lines[i]);
                  const optText = lines[i].replace(/^\(\s*[x\s]?\s*\)\s*/, '');
                  options.push({ text: optText, isCorrect, id: Math.random().toString(36).slice(2) });
                }
              }

              if (options.length >= 2) {
                updates.push({
                  from: offset,
                  to: offset + node.nodeSize,
                  type: 'mcq',
                  attrs: { question, options }
                });
                return;
              }
            }
          }
        });

        // 2. Multi-Paragraph MCQ Detection
        let mcqStart = -1;
        let questionText = '';
        let options = [];
        let nodesToRemove = [];

        state.doc.forEach((node, offset) => {
          if (updates.some(u => u.from === offset)) return;

          if (node.type.name === 'paragraph') {
            const text = node.textContent.trim();

            if (text.startsWith('? ')) {
              if (mcqStart !== -1) {
                mcqStart = -1;
                options = [];
                nodesToRemove = [];
              }
              mcqStart = offset;
              questionText = text.slice(2).trim();
              nodesToRemove.push({ from: offset, to: offset + node.nodeSize });
              return;
            }

            if (mcqStart !== -1 && /^\(\s*[x\s]?\s*\)/.test(text)) {
              const isCorrect = /^\(\s*x\s*\)/i.test(text);
              const optText = text.replace(/^\(\s*[x\s]?\s*\)\s*/, '');
              options.push({ text: optText, isCorrect, id: Math.random().toString(36).slice(2) });
              nodesToRemove.push({ from: offset, to: offset + node.nodeSize });
              return;
            }

            if (mcqStart !== -1) {
              if (options.length > 0) {
                updates.push({
                  from: nodesToRemove[0].from,
                  to: nodesToRemove[nodesToRemove.length - 1].to,
                  type: 'mcq',
                  attrs: { question: questionText, options: [...options] }
                });
              }
              mcqStart = -1;
              options = [];
              nodesToRemove = [];
            }
          }
        });

        if (mcqStart !== -1 && options.length > 0) {
          updates.push({
            from: nodesToRemove[0].from,
            to: nodesToRemove[nodesToRemove.length - 1].to,
            type: 'mcq',
            attrs: { question: questionText, options: [...options] }
          });
        }

        if (updates.length > 0) {
          updates.sort((a, b) => b.from - a.from);
          const transaction = editor.state.tr;
          updates.forEach(u => {
            if (u.type === 'callout') {
              const paragraph = editor.schema.nodes.paragraph.create(null, editor.schema.text(u.content || ''));
              transaction.replaceWith(u.from, u.to, editor.schema.nodes.callout.create(u.attrs, paragraph));
            } else {
              transaction.replaceWith(u.from, u.to, editor.schema.nodes[u.type].create(u.attrs));
            }
          });
          editor.view.dispatch(transaction);
        }
      };

      return { GlobalShortcuts, SlashCommand, PremiumDragHandle, CtrlArrowBlockJump, convertCustomBlocksRobust };
    })();

    /* ====================== SECTION: AI_LAYER ====================== */
    const AI = (() => {

      const buildPrompt = (action, selection, fullDoc, param = '') => {
        const baseSystem = `
      You are an AI writing assistant for a structured rich text editor.

You MUST output STRICT MARKDOWN ONLY.
Do NOT use JSON.
Do NOT use HTML.
Do NOT wrap entire response in a single code block.
Do NOT add conversational phrases like "Here is" or "Sure".

==============================
FORMATTING RULES (MANDATORY)
==============================

HEADINGS
- Use # for main title
- Use ## for sections
- Use ### for subsections
- Do NOT use #### or deeper

PARAGRAPHS
- Maximum 4 lines per paragraph
- Always leave ONE blank line between paragraphs
- Never output one large paragraph

BULLET LIST
- Use "- " only
- Leave one blank line before list
- Do NOT use "*"

NUMBERED LIST
1. Step one
2. Step two
- Leave one blank line before list

CODE BLOCK
Use triple backticks with language:
\`\`\`python
code here
\`\`\`
Only use code blocks if user asks for example code.

MATH
Inline math: $a^2 + b^2$
Block math:
$$
a^2 + b^2 = c^2
$$
Always place block math on separate lines.

==============================
MCQ FORMAT (ONLY IF USER ASKS)
==============================

Use EXACT format:

? Question text
( ) Option A
(x) Correct Option
( ) Option C
( ) Option D

Rules:
- Each option MUST be on a new line
- "(x)" marks the correct answer
- Leave one blank line between questions
- Do NOT use markdown formatting inside MCQ
- Do NOT mix explanation inside MCQ block

If user asks for both explanation and MCQ:
1. Write explanation first
2. Leave one blank line
3. Then write MCQ section

Output only structured educational content.
    `;

        const context = fullDoc.slice(-3000);

        let prompt = '';

        switch (action) {

          case 'improve':
            prompt = `
Rewrite the following text to be professional, clear, and educational.

Text:
"${selection}"
`;
            break;

          case 'summarize':
            prompt = `
Summarize the following content in structured bullet format.

Text:
"${selection}"
`;
            break;

          case 'explain':
            prompt = `
Explain this concept clearly for students.
Use structured sections if helpful.

Text:
"${selection}"
`;
            break;

          case 'continue':
            prompt = `
Continue the document naturally from where it ends.

Rules:
- Do NOT rewrite existing content.
- Maintain the same heading hierarchy.
- Add new sections if appropriate.
- Output STRICT MARKDOWN only.
- Do not use JSON.

Document Context:
${context}
`;
            break;

          case 'convert-to-notes':
            prompt = `
Convert this content into structured study notes.
Use headings and bullet points where appropriate.

Text:
"${selection}"
`;
            break;

          case 'fix-grammar':
            prompt = `
Correct ONLY grammar and spelling mistakes.

STRICT RULES:
- Do NOT rewrite sentences.
- Do NOT improve wording.
- Do NOT add new sentences.
- Do NOT remove content.
- Do NOT change structure.
- Keep the exact same formatting.
- Return the same number of sentences.
- If there are no grammar mistakes, return the original text unchanged.

Text:
"${selection}"
`;
            break;

          case 'rewrite-tone':
            prompt = `
Rewrite ONLY the provided text in ${param} tone.

STRICT RULES:
- Do NOT add new information.
- Do NOT add headings.
- Do NOT reference other document sections.
- Do NOT expand beyond the original idea.
- Keep it approximately the same length.
- Output only the rewritten sentence.

Text:
"${selection}"
`;
            break;

          case 'generate-mcq':
            prompt = `
Generate multiple choice questions using the EXACT MCQ format defined above.

Text:
"${selection}"
`;
            break;

          case 'write':
            prompt = `
Generate structured educational content based on the following instruction.
Use headings, paragraphs, lists, math, or code if appropriate.

Instruction:
"${selection}"
`;
            break;

          default:
            prompt = `
${action}

Text:
"${selection}"
`;
        }

        return `${baseSystem}\n\n${prompt}`;
      };

      const handleRequest = async (action, param) => {
        if (!window.editorInstance) return;
        const editor = window.editorInstance;

        const { state } = editor;
        let { from, to, empty } = state.selection;
        let selectedText = state.doc.textBetween(from, to, ' ');

        // Fallback: If no selection, grab the current paragraph/block for context
        if (empty || !selectedText.trim()) {
          const { $from } = state.selection;
          const parent = $from.parent;

          // Only if it's a text block (like paragraph, heading)
          if (parent.isTextblock) {
            from = $from.start();
            to = $from.end();
            selectedText = state.doc.textBetween(from, to, ' ');
          }
        }

        if (!selectedText && action !== 'continue' && action !== 'write') {
          alert('Please select some text first.');
          return;
        }

        UI.aiUI.show();

        try {
          const prompt = buildPrompt(action, selectedText, editor.getText(), param);

          const res = await fetch(CONFIG.GEMINI_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              contents: [{ parts: [{ text: prompt }] }]
            })
          });

          const data = await res.json();
          const aiText = data.candidates?.[0]?.content?.parts?.[0]?.text;

          if (!aiText) throw new Error('No response from AI');

          const previewHTML = window.marked ? window.marked.parse(aiText) : aiText; // Assuming marked is loaded via Tiptap Markdown or simple script? 
          // We don't have 'marked' global. We can use simplified preview or just text.
          // Actually, Tiptap Markdown extension handles markdown.
          // For the preview, let's just show text or basic HTML if we had a parser.
          // The original code used `marked.parse` but we didn't see `marked` imported. 
          // Ah, `import { Markdown }` from tiptap-markdown doesn't expose marked globally.
          // Let's just assume text is okay or do simple replace for preview.
          // Wait, looking at original code, it might have assumed 'marked' was available or I missed an import.
          // Let's just use textContent for safety in preview, or simple conversion.

          UI.aiUI.updatePreview(previewHTML); // Using text as HTML might be risky if not parsed, but safe from AI?

          UI.aiUI.setSuccess();
          const userConfirmed = await UI.aiUI.waitForUser();

          if (userConfirmed) {
            const chain = editor.chain().focus();
            // Smart Placement Logic
            let mode = 'replace';

            // If user is just asking a question (short text), replace it with the answer.
            // If user is selecting a long text (context), append the result (e.g. MCQ based on text).
            if (action === 'generate-mcq') {
              if (selectedText.length > 200) mode = 'append';
              else mode = 'replace';
            }
            if (action === 'continue') mode = 'append';

            if (mode === 'replace') {
              chain.deleteRange({ from, to });
            } else {
              // Append mode: Move to end and ensure separation
              chain.setTextSelection(to);
              const endNode = editor.state.doc.nodeAt(to - 1); // Check node before cursor
              // Insert a break if needed
              chain.insertContent('\n');
            }

            try {
              chain.insertContent(aiText);
            } catch (err) {
              chain.insertContent(aiText);
            }

            chain.run();

            // Post-process for custom blocks
            setTimeout(() => {
              PLUGINS.convertCustomBlocksRobust(editor);
            }, 50);
          }
        } catch (e) {
          console.error(e);
          UI.aiUI.setError(e.message || 'AI request failed');
          await UI.aiUI.waitForUser();
        } finally {
          UI.aiUI.hide();
        }
      };

      return { handleRequest };
    })();

    /* ====================== SECTION: EDITOR_INIT ====================== */
    const EDITOR_INIT = (() => {
      const initialContent = localStorage.getItem(CONFIG.STORAGE_KEY)
        ? JSON.parse(localStorage.getItem(CONFIG.STORAGE_KEY))
        : CONFIG.DEFAULT_CONTENT;

      const editor = new Editor({
        element: document.querySelector('#editor'),
        extensions: [
          Document,
          Paragraph,
          Text,
          Blockquote,
          BulletList,
          OrderedList,
          ListItem,
          HardBreak,
          HorizontalRule,
          Heading.configure({ levels: [1, 2, 3] }),
          Bold,
          Italic,
          Strike,
          Code,
          History,
          Dropcursor,
          Gapcursor,
          Image,
          Link.configure({ openOnClick: false }),
          Youtube.configure({ inline: false }),
          Table.configure({ resizable: true }),
          TableRow,
          TableHeader,
          TableCell,
          Placeholder.configure({ placeholder: 'Type / to browse commands...' }),
          TaskList,
          TaskItem.configure({ nested: true }),
          Markdown,
          PLUGINS.GlobalShortcuts,
          PLUGINS.SlashCommand,
          PLUGINS.PremiumDragHandle,
          PLUGINS.CtrlArrowBlockJump,
          NODES.Video,
          NODES.CustomImage,
          NODES.FileAttachment,
          NODES.MathBlock,
          NODES.Callout,
          NODES.PageBreak,
          NODES.CustomCodeBlock.configure({ lowlight: CONFIG.lowlight }),
          NODES.Mcq,
          BubbleMenu.configure({
            element: document.querySelector('#ai-bubble-menu'),
            tippyOptions: { duration: 100 },
            shouldShow: ({ editor, view, state, from, to }) => {
              // Show only on text selection, not block selection
              return !view.state.selection.empty && !editor.isActive('image') && !editor.isActive('video');
            },
          }),
        ],
        content: initialContent,
        editorProps: {
          attributes: {
            class: 'prose prose-slate max-w-none focus:outline-none',
            spellcheck: 'false',
          },
        },
        onUpdate: ({ editor }) => {
          // Save content
          const json = editor.getJSON();
          localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(json));

          // Update Debug View
          document.getElementById('debug-json').textContent = JSON.stringify(json, null, 2);

          // Robust Block Conversion (debounce slightly?)
          // We call it on every update, but it's optimized to only touch specific nodes
          PLUGINS.convertCustomBlocksRobust(editor);
        },
        onSelectionUpdate: ({ editor }) => {
          // Table Menu Logic
          const { selection } = editor.state;
          const tableMenu = document.querySelector('#table-bubble-menu');
          if (editor.isActive('table')) {
            if (tableMenu) {
              UI.setupTableMenu(editor);
              tableMenu.classList.remove('hidden');
              // Position near cursor or table?
              // Simple absolute positioning near cursor
              const { from } = selection;
              const start = editor.view.coordsAtPos(from);
              tableMenu.style.top = (start.top + window.scrollY - 40) + 'px';
              tableMenu.style.left = start.left + 'px';
            }
          } else {
            if (tableMenu) tableMenu.classList.add('hidden');
          }
        }
      });

      // Expose editor instance for AI layer to access
      window.editorInstance = editor;

      // Initialize UI components that depend on editor
      document.querySelectorAll('.ai-btn').forEach(btn => {
        btn.onclick = (e) => {
          e.preventDefault();
          AI.handleRequest(btn.dataset.action);
        };
      });

    })();
  </script>
</body>

</html>