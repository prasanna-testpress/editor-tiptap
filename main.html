<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TipTap ‚Äî Premium Editor</title>

  <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
  <link
    href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800&family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap"
    rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">

  <style>
    /* Premium Design System */
    :root {
      --plate-bg: #ffffff;
      --plate-border: #e2e8f0;
      --plate-accent: #3b82f6;
      --font-outfit: 'Outfit', sans-serif;
      --font-inter: 'Inter', sans-serif;
      --font-mono: 'JetBrains Mono', monospace;
    }

    body {
      font-family: var(--font-inter);
      background: #f8fafc;
      min-height: 100vh;
      color: #1e293b;
    }

    /* Custom Scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }

    ::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 10px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #94a3b8;
    }

    /* Editor Canvas */
    .ProseMirror {
      outline: none;
      min-height: 600px;
      padding: 60px 80px;
      font-size: 1.05rem;
      line-height: 1.8;
    }

    @media (max-width: 768px) {
      .ProseMirror {
        padding: 40px 24px;
      }
    }

    /* Typography */
    .ProseMirror h1,
    .ProseMirror h2,
    .ProseMirror h3 {
      font-family: var(--font-outfit);
      color: #0f172a;
      line-height: 1.2;
    }

    .ProseMirror h1 {
      font-size: 2.75rem;
      font-weight: 800;
      margin: 2.5rem 0 1.5rem;
    }

    .ProseMirror h2 {
      font-size: 2rem;
      font-weight: 700;
      margin: 2rem 0 1rem;
    }

    .ProseMirror h3 {
      font-size: 1.5rem;
      font-weight: 600;
      margin: 1.5rem 0 0.75rem;
    }

    .ProseMirror p {
      margin-bottom: 1.25rem;
    }

    .ProseMirror a {
      color: var(--plate-accent);
      text-decoration: underline;
      cursor: pointer;
    }

    /* Drag Handle */
    .ProseMirror>* {
      position: relative;
    }

    .ProseMirror>*:hover::before {
      content: "‚ãÆ‚ãÆ";
      position: absolute;
      left: -35px;
      top: 0;
      color: #cbd5e1;
      font-size: 16px;
      cursor: grab;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .ProseMirror>*:hover::before:hover {
      background: #f1f5f9;
      color: var(--plate-accent);
    }

    /* Lists */
    .ProseMirror ul,
    .ProseMirror ol {
      padding: 0 1rem;
      margin: 1.25rem 1rem 1.25rem 0.4rem;
    }

    .ProseMirror ul li {
      list-style-type: disc;
    }

    .ProseMirror ol li {
      list-style-type: decimal;
    }

    .ProseMirror li {
      margin-bottom: 0.5rem;
      padding-left: 0.5rem;
    }

    /* Task List */
    ul[data-type="taskList"] {
      list-style: none;
      padding: 0;
    }

    ul[data-type="taskList"] li {
      display: flex;
      gap: 12px;
      margin-bottom: 8px;
      align-items: flex-start;
    }

    ul[data-type="taskList"] li>label {
      flex: 0 0 auto;
      margin-right: 0.5rem;
      user-select: none;
      margin-top: 0.3em;
    }

    ul[data-type="taskList"] li>div {
      flex: 1 1 auto;
    }

    ul[data-type="taskList"] input[type="checkbox"] {
      cursor: pointer;
      width: 1.1em;
      height: 1.1em;
      accent-color: var(--plate-accent);
    }

    ul[data-type="taskList"] li[data-checked="true"]>div {
      text-decoration: line-through;
      color: #94a3b8;
    }

    /* Blockquote */
    .ProseMirror blockquote {
      border-left: 4px solid var(--plate-accent);
      margin: 1.5rem 0;
      padding-left: 1rem;
      font-style: italic;
      color: #475569;
      background: #f8fafc;
      padding: 1rem;
      border-radius: 0 8px 8px 0;
    }

    /* Code Block */
    pre {
      background: #0d1117;
      border-radius: 0.75rem;
      color: #c9d1d9;
      font-family: var(--font-mono);
      padding: 2.5rem 1.5rem 1.5rem;
      margin: 1.5rem 0;
      position: relative;
      overflow-x: auto;
    }

    pre code {
      background: none;
      color: inherit;
      font-size: 0.85rem;
      padding: 0;
    }

    .hljs-comment,
    .hljs-quote {
      color: #8b949e;
    }

    .hljs-variable,
    .hljs-template-variable,
    .hljs-tag,
    .hljs-name,
    .hljs-selector-id,
    .hljs-selector-class,
    .hljs-regexp,
    .hljs-deletion {
      color: #d2a8ff;
    }

    .hljs-number,
    .hljs-built_in,
    .hljs-builtin-name,
    .hljs-literal,
    .hljs-type,
    .hljs-params,
    .hljs-meta,
    .hljs-link {
      color: #79c0ff;
    }

    .hljs-section,
    .hljs-title {
      color: #d2a8ff;
    }

    .hljs-keyword,
    .hljs-selector-tag {
      color: #ff7b72;
    }

    /* Language Selecror */
    .language-selector {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      background: #21262d;
      color: #c9d1d9;
      border: 1px solid #30363d;
      border-radius: 4px;
      font-size: 0.75rem;
      padding: 2px 6px;
      z-index: 10;
      opacity: 0.5;
      transition: opacity 0.2s;
      cursor: pointer;
    }

    .code-block-wrapper:hover .language-selector {
      opacity: 1;
    }

    /* Tables */
    .tableWrapper {
      margin: 2rem 0;
      overflow-x: auto;
    }

    table {
      border-collapse: collapse;
      table-layout: fixed;
      width: 100%;
      margin: 0;
      overflow: hidden;
      border-radius: 8px;
    }

    td,
    th {
      min-width: 1em;
      border: 1px solid #cbd5e1;
      padding: 10px 12px;
      vertical-align: top;
      box-sizing: border-box;
      position: relative;
    }

    th {
      font-weight: 600;
      text-align: left;
      background-color: #f1f5f9;
    }

    .selectedCell:after {
      z-index: 2;
      position: absolute;
      content: "";
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      background: rgba(59, 130, 246, 0.15);
      pointer-events: none;
    }

    /* Images & Video */
    img {
      max-width: 100%;
      height: auto;
      border-radius: 12px;
      margin: 1.5rem 0;
      display: block;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
    }

    iframe {
      width: 100%;
      aspect-ratio: 16/9;
      border-radius: 12px;
      margin: 1.5rem 0;
      border: none;
      background: #000;
    }

    /* Callouts */
    .callout {
      padding: 1.25rem;
      border-radius: 0.75rem;
      margin: 1.5rem 0;
      border: 1px solid transparent;
      display: flex;
      gap: 1rem;
      align-items: flex-start;
    }

    .callout-info {
      background: #eff6ff;
      border-color: #bfdbfe;
      color: #1e40af;
    }

    .callout-success {
      background: #f0fdf4;
      border-color: #bbf7d0;
      color: #166534;
    }

    .callout-warning {
      background: #fffbeb;
      border-color: #fde68a;
      color: #92400e;
    }

    .callout-error {
      background: #fef2f2;
      border-color: #fecaca;
      color: #991b1b;
    }

    .callout div p {
      margin: 0;
    }

    .callout-icon {
      font-size: 1.25rem;
      line-height: 1;
      user-select: none;
    }

    /* Page Break */
    .page-break {
      margin: 2rem 0;
      border: none;
      border-top: 2px dashed #cbd5e1;
      position: relative;
      height: 1px;
    }

    .page-break::after {
      content: "Page Break";
      position: absolute;
      top: -10px;
      left: 50%;
      transform: translateX(-50%);
      background: #f8fafc;
      padding: 0 10px;
      color: #94a3b8;
      font-size: 0.75rem;
      font-weight: 500;
      text-transform: uppercase;
    }

    /* Math Block Improved */
    .math-block-container {
      margin: 1.5rem 0;
      border-radius: 0.5rem;
      border: 1px solid transparent;
      transition: all 0.2s;
    }

    .math-block-container:hover {
      border-color: #e2e8f0;
    }

    .math-block-container.is-editing {
      border-color: var(--plate-accent);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
      background: #fff;
    }

    .math-preview {
      padding: 1rem;
      text-align: center;
      cursor: pointer;
      min-height: 2.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f8fafc;
      border-radius: 0.5rem;
    }

    .math-preview:hover {
      background: #f1f5f9;
    }

    .math-input {
      width: 100%;
      padding: 0.75rem;
      font-family: var(--font-mono);
      font-size: 0.9rem;
      background: #1e293b;
      color: #e2e8f0;
      border: none;
      border-radius: 0 0 0.5rem 0.5rem;
      outline: none;
      resize: vertical;
      display: none;
      /* Hidden by default */
    }

    .is-editing .math-preview {
      border-radius: 0.5rem 0.5rem 0 0;
      border-bottom: 1px solid #e2e8f0;
      background: #fff;
    }

    .is-editing .math-input {
      display: block;
    }

    .katex-display {
      margin: 0 !important;
    }

    /* Slash Menu */
    .slash-popup {
      background: white;
      border: 1px solid #e2e8f0;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
      border-radius: 12px;
      width: 300px;
      max-height: 360px;
      overflow-y: auto;
      padding: 0.5rem;
      z-index: 50;
      display: none;
      /* hidden initially */
    }

    .slash-group {
      margin-bottom: 0.5rem;
    }

    .slash-group-title {
      font-size: 0.75rem;
      font-weight: 600;
      color: #94a3b8;
      padding: 0.5rem 0.75rem 0.25rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .slash-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      color: #334155;
      font-size: 0.9rem;
      transition: all 0.15s;
    }

    .slash-item:hover {
      background: #f8fafc;
    }

    .slash-item.is-selected {
      background: #eff6ff;
      color: #2563eb;
    }

    .slash-item-icon {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f1f5f9;
      border-radius: 4px;
      font-size: 0.8rem;
      color: #64748b;
    }

    .slash-item.is-selected .slash-item-icon {
      background: #dbeafe;
      color: #2563eb;
    }

    .slash-item-content {
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .slash-item-title {
      font-weight: 500;
      line-height: 1.2;
    }

    .slash-item-desc {
      font-size: 0.75rem;
      color: #94a3b8;
      line-height: 1.2;
      margin-top: 2px;
    }

    /* Placeholders */
    .is-empty::before {
      content: attr(data-placeholder);
      float: left;
      color: #adb5bd;
      pointer-events: none;
      height: 0;
    }

    /* Modal System */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
    }

    .modal-overlay.active {
      opacity: 1;
      pointer-events: all;
    }

    .modal-card {
      background: white;
      width: 100%;
      max-width: 420px;
      padding: 24px;
      border-radius: 16px;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      transform: scale(0.95);
      transition: transform 0.2s;
    }

    .modal-overlay.active .modal-card {
      transform: scale(1);
    }

    .modal-title {
      font-size: 1.25rem;
      font-weight: 700;
      margin-bottom: 1rem;
      color: #0f172a;
    }

    .modal-input {
      width: 100%;
      padding: 10px 14px;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      margin-bottom: 1.5rem;
      outline: none;
      transition: border-color 0.2s;
    }

    .modal-input:focus {
      border-color: var(--plate-accent);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
    }

    .btn {
      padding: 8px 16px;
      border-radius: 8px;
      font-weight: 500;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-secondary {
      background: #f1f5f9;
      color: #475569;
    }

    .btn-secondary:hover {
      background: #e2e8f0;
    }

    .btn-primary {
      background: var(--plate-accent);
      color: white;
    }

    .btn-primary:hover {
      background: #2563eb;
    }

    /* Bubble Menu (Tables) */
    .bubble-menu {
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      display: flex;
      padding: 4px;
      gap: 4px;
      position: absolute;
      z-index: 20;
    }

    .bubble-menu.hidden {
      display: none;
    }

    .bubble-btn {
      background: transparent;
      border: none;
      color: #64748b;
      padding: 6px;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
    }

    .bubble-btn:hover {
      background: #f1f5f9;
      color: #0f172a;
    }

    /* Resize Handles */
    .node-image,
    .node-video {
      display: block;
      /* position: relative; set by style */
      user-select: none;
      line-height: 0;
      /* Remove bottom gap */
    }

    .node-image img,
    .node-video video {
      display: block;
      width: 100%;
      height: auto;
    }

    .resize-handle {
      position: absolute;
      right: -6px;
      bottom: -6px;
      width: 12px;
      height: 12px;
      background: #3b82f6;
      border: 2px solid white;
      border-radius: 50%;
      cursor: nwse-resize;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 10;
    }

    .ProseMirror-selectednode .resize-handle,
    .node-container:hover .resize-handle {
      opacity: 1;
    }

    /* File Attachment */
    .file-attachment {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      margin: 1.5rem 0;
      text-decoration: none;
      transition: all 0.2s;
      width: fit-content;
      cursor: pointer;
    }

    .file-attachment:hover {
      background: #f1f5f9;
      border-color: #cbd5e1;
    }

    .file-icon {
      font-size: 1.5rem;
    }

    .file-info {
      display: flex;
      flex-direction: column;
    }

    .file-name {
      font-weight: 500;
      color: #334155;
      font-size: 0.95rem;
    }

    .file-size {
      font-size: 0.75rem;
      color: #64748b;
    }
  </style>
</head>

<body class="flex flex-col items-center py-12">

  <div class="w-full max-w-5xl lg:px-8">
    <!-- Header -->
    <div class="mb-10 px-6 lg:px-0 text-center">
      <h1 class="text-4xl font-extrabold tracking-tight text-slate-900 mb-2 font-[Outfit]">Premium Editor</h1>
      <p class="text-slate-500">
        Type <code class="bg-white border border-slate-200 px-1.5 py-0.5 rounded text-sm mx-1 shadow-sm">/</code> to
        browse commands
      </p>
    </div>

    <!-- Editor Container -->
    <div class="bg-white border border-slate-200 rounded-2xl shadow-xl overflow-hidden min-h-[80vh] mx-4 relative">
      <div id="editor"></div>
    </div>

    <div
      class="mt-8 bg-slate-100 rounded-lg p-4 mx-4 text-xs font-mono text-slate-600 overflow-auto max-h-96 w-full max-w-5xl">
      <div class="font-bold mb-2">Debug JSON:</div>
      <pre id="debug-json">{}</pre>
    </div>
  </div>

  <!-- Table Controls (Bubble Menu Container) -->
  <div id="table-bubble-menu" class="hidden">
    <!-- Buttons injected by JS -->
  </div>

  <!-- AI Bubble Menu -->
  <div id="ai-bubble-menu"
    class="hidden flex items-center gap-1 bg-white border border-slate-200 rounded-lg shadow-lg p-1">
    <button data-action="improve"
      class="ai-btn flex items-center gap-2 px-2 py-1 text-sm text-slate-600 hover:bg-slate-100 rounded">
      <span>‚ú®</span> Improve
    </button>
    <button data-action="summarize"
      class="ai-btn flex items-center gap-2 px-2 py-1 text-sm text-slate-600 hover:bg-slate-100 rounded">
      <span>üìù</span> Summarize
    </button>
    <button data-action="explain"
      class="ai-btn flex items-center gap-2 px-2 py-1 text-sm text-slate-600 hover:bg-slate-100 rounded">
      <span>ü§î</span> Explain
    </button>
    <button data-action="continue"
      class="ai-btn flex items-center gap-2 px-2 py-1 text-sm text-slate-600 hover:bg-slate-100 rounded">
      <span>‚û°Ô∏è</span> Continue
    </button>
    <div id="ai-loader" class="hidden ml-2">
      <div class="animate-spin h-4 w-4 border-2 border-blue-500 border-t-transparent rounded-full"></div>
    </div>
  </div>

  <!-- Universal Modal -->
  <div id="ui-modal" class="modal-overlay">
    <div class="modal-card">
      <h3 id="modal-title" class="modal-title">Insert Content</h3>
      <input type="text" id="modal-input" class="modal-input" placeholder="https://..." />
      <div class="modal-actions">
        <button id="modal-cancel" class="btn btn-secondary">Cancel</button>
        <button id="modal-confirm" class="btn btn-primary">Insert</button>
      </div>
    </div>
  </div>
  </div>

  <!-- Loading Overlay -->
  <div id="loading-overlay" class="modal-overlay" style="z-index: 200;">
    <div class="bg-white p-6 rounded-lg shadow-xl flex flex-col items-center">
      <div class="animate-spin rounded-full h-10 w-10 border-b-2 border-blue-600 mb-4"></div>
      <p class="text-slate-600 font-medium">Uploading...</p>
    </div>
  </div>

  <script type="module">
    import { Editor, Node, mergeAttributes, Extension, InputRule } from 'https://esm.sh/@tiptap/core@2.11.5?bundle';

    import Document from 'https://esm.sh/@tiptap/extension-document@2.11.5?bundle';
    import Paragraph from 'https://esm.sh/@tiptap/extension-paragraph@2.11.5?bundle';
    import Text from 'https://esm.sh/@tiptap/extension-text@2.11.5?bundle';
    import Blockquote from 'https://esm.sh/@tiptap/extension-blockquote@2.11.5?bundle';
    import BulletList from 'https://esm.sh/@tiptap/extension-bullet-list@2.11.5?bundle';
    import OrderedList from 'https://esm.sh/@tiptap/extension-ordered-list@2.11.5?bundle';
    import ListItem from 'https://esm.sh/@tiptap/extension-list-item@2.11.5?bundle';
    import HardBreak from 'https://esm.sh/@tiptap/extension-hard-break@2.11.5?bundle';
    import HorizontalRule from 'https://esm.sh/@tiptap/extension-horizontal-rule@2.11.5?bundle';
    import Heading from 'https://esm.sh/@tiptap/extension-heading@2.11.5?bundle';
    import Bold from 'https://esm.sh/@tiptap/extension-bold@2.11.5?bundle';
    import Code from 'https://esm.sh/@tiptap/extension-code@2.11.5?bundle';
    import Italic from 'https://esm.sh/@tiptap/extension-italic@2.11.5?bundle';
    import Strike from 'https://esm.sh/@tiptap/extension-strike@2.11.5?bundle';
    import Dropcursor from 'https://esm.sh/@tiptap/extension-dropcursor@2.11.5?bundle';
    import Gapcursor from 'https://esm.sh/@tiptap/extension-gapcursor@2.11.5?bundle';
    import History from 'https://esm.sh/@tiptap/extension-history@2.11.5?bundle';
    import Placeholder from 'https://esm.sh/@tiptap/extension-placeholder@2.11.5?bundle';
    import TaskList from 'https://esm.sh/@tiptap/extension-task-list@2.11.5?bundle';
    import TaskItem from 'https://esm.sh/@tiptap/extension-task-item@2.11.5?bundle';
    import Link from 'https://esm.sh/@tiptap/extension-link@2.11.5?bundle';
    import Image from 'https://esm.sh/@tiptap/extension-image@2.11.5?bundle';
    import Table from 'https://esm.sh/@tiptap/extension-table@2.11.5?bundle';
    import TableRow from 'https://esm.sh/@tiptap/extension-table-row@2.11.5?bundle';
    import TableCell from 'https://esm.sh/@tiptap/extension-table-cell@2.11.5?bundle';
    import TableHeader from 'https://esm.sh/@tiptap/extension-table-header@2.11.5?bundle';
    import Youtube from 'https://esm.sh/@tiptap/extension-youtube@2.11.5?bundle';
    import { BubbleMenu } from 'https://esm.sh/@tiptap/extension-bubble-menu@2.11.5?bundle';
    import CodeBlockLowlight from 'https://esm.sh/@tiptap/extension-code-block-lowlight@2.11.5?bundle';
    import { common, createLowlight } from 'https://esm.sh/lowlight?bundle';
    import katex from 'https://esm.sh/katex';
    import Suggestion from 'https://esm.sh/@tiptap/suggestion@2.11.5?bundle';
    import { Plugin } from 'https://esm.sh/prosemirror-state?bundle';

    /* --- Constants --- */
    const GEMINI_API_KEY = ''; // Replace with actual key or env var if possible
    const GEMINI_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;


    // Initialize Lowlight (Syntax Highlighting)
    const lowlight = createLowlight(common);

    /* --- Custom UI Helpers --- */
    const Modal = {
      overlay: document.getElementById('ui-modal'),
      title: document.getElementById('modal-title'),
      input: document.getElementById('modal-input'),
      confirm: document.getElementById('modal-confirm'),
      cancel: document.getElementById('modal-cancel'),
      resolve: null,

      open(title, placeholder = 'Enter URL...') {
        this.title.textContent = title;
        this.input.placeholder = placeholder;
        this.input.value = '';
        this.overlay.classList.add('active');
        this.input.focus();

        return new Promise((resolve) => {
          this.resolve = resolve;
        });
      },

      close() {
        this.overlay.classList.remove('active');
        this.resolve = null;
      }
    };

    Modal.confirm.onclick = () => {
      if (Modal.resolve) Modal.resolve(Modal.input.value);
      Modal.close();
    };

    Modal.cancel.onclick = () => {
      if (Modal.resolve) Modal.resolve(null);
      Modal.close();
    };

    Modal.input.onkeydown = (e) => {
      if (e.key === 'Enter') Modal.confirm.click();
      if (e.key === 'Escape') Modal.cancel.click();
    };

    /* --- File Upload Helper --- */
    const triggerFileUpload = (accept) => {
      return new Promise((resolve) => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = accept;
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (file) {
            const loading = document.getElementById('loading-overlay');
            loading.classList.add('active'); // Show loading

            // Use URL.createObjectURL instead of FileReader for performance.
            // Reading large files (videos) as Base64 strings (readAsDataURL) freezes the main thread.
            // Blob URLs are instant and lightweight.
            const objectUrl = URL.createObjectURL(file);

            // Simulate a small network delay for realism/UX
            setTimeout(() => {
              loading.classList.remove('active'); // Hide loading
              resolve({
                src: objectUrl,
                name: file.name,
                size: file.size,
                type: file.type
              });
            }, 600);
          } else {
            resolve(null);
          }
        };
        input.click();
      });
    };

    /* --- Resizable Node View Factory --- */
    const createResizableNodeView = (type) => {
      return ({ node, editor, getPos }) => {
        const container = document.createElement('div');
        container.classList.add('node-container'); // Helper class for hover
        container.style.position = 'relative';
        container.style.display = 'inline-block';
        container.style.maxWidth = '100%';
        container.style.margin = '1.5rem 0';
        container.style.lineHeight = '0';

        // Initial width
        container.style.width = node.attrs.width || '100%';

        const media = document.createElement(type === 'video' ? 'video' : 'img');
        if (type === 'video') {
          media.controls = true;
          // Prevent drag on video controls from conflicting?
        }
        media.style.borderRadius = '12px';
        media.src = node.attrs.src;
        media.style.width = '100%';
        media.style.height = 'auto';
        media.style.display = 'block';
        // media.draggable = false; // Let container handle selection

        const handle = document.createElement('div');
        handle.className = 'resize-handle';

        // Drag logic
        handle.addEventListener('mousedown', (e) => {
          e.preventDefault();
          e.stopPropagation(); // Stop editor selection
          const startX = e.clientX;
          const startWidth = container.offsetWidth;

          const onMouseMove = (e) => {
            const currentX = e.clientX;
            const diffX = currentX - startX;
            const newWidth = Math.max(100, startWidth + diffX);
            container.style.width = `${newWidth}px`;
          };

          const onMouseUp = () => {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            if (typeof getPos === 'function') {
              const pos = getPos();
              if (pos !== undefined && pos !== null) {
                editor.commands.updateAttributes(pos, { width: container.style.width });
              }
            }
          };

          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        });

        container.append(media, handle);

        return {
          dom: container,
          update: (updatedNode) => {
            if (updatedNode.type.name !== (type === 'video' ? 'video' : 'image')) return false;
            if (updatedNode.attrs.src !== node.attrs.src) media.src = updatedNode.attrs.src;
            if (updatedNode.attrs.width !== node.attrs.width) container.style.width = updatedNode.attrs.width;
            node = updatedNode;
            return true;
          },
          selectNode: () => {
            container.classList.add('ProseMirror-selectednode');
            media.style.outline = '3px solid #3b82f6';
            media.style.outlineOffset = '2px';
          },
          deselectNode: () => {
            container.classList.remove('ProseMirror-selectednode');
            media.style.outline = 'none';
          }
        };
      }
    }

    // 0. Video Node (Local)
    const Video = Node.create({
      name: 'video',
      group: 'block',
      selectable: true,
      draggable: true,
      atom: true,

      addAttributes() {
        return {
          src: { default: null },
          width: { default: '100%' }
        }
      },

      parseHTML() {
        return [{ tag: 'video' }]
      },

      renderHTML({ HTMLAttributes }) {
        return ['video', mergeAttributes(HTMLAttributes, { controls: 'true', style: `width: ${HTMLAttributes.width}` })]
      },

      addNodeView() {
        return createResizableNodeView('video');
      }
    });

    // Custom Image Node for Resizing
    const CustomImage = Image.extend({
      addAttributes() {
        // Safe fallback for parent attributes
        const parentAttrs = this.parent ? this.parent() : {};
        return {
          ...parentAttrs,
          width: { default: '100%' }
        }
      },
      addNodeView() {
        return createResizableNodeView('image');
      }
    });

    // 0. File Attachment Node
    const FileAttachment = Node.create({
      name: 'fileAttachment',
      group: 'block',
      atom: true,

      addAttributes() {
        return {
          src: { default: null },
          name: { default: 'file' },
          size: { default: 0 }
        }
      },

      parseHTML() {
        return [{ tag: 'div[data-type="file-attachment"]' }]
      },

      renderHTML({ HTMLAttributes }) {
        return ['div', mergeAttributes(HTMLAttributes, { 'data-type': 'file-attachment' })]
      },

      addNodeView() {
        return ({ node }) => {
          const dom = document.createElement('a');
          dom.className = 'file-attachment';
          dom.href = node.attrs.src;
          dom.download = node.attrs.name;
          dom.contentEditable = 'false';

          const sizeKB = (node.attrs.size / 1024).toFixed(1);

          dom.innerHTML = `
            <div class="file-icon">üìé</div>
            <div class="file-info">
              <span class="file-name">${node.attrs.name}</span>
              <span class="file-size">${sizeKB} KB</span>
            </div>
          `;

          return { dom };
        }
      }
    });

    // 1. Math Block
    const MathBlock = Node.create({
      name: 'mathBlock',
      group: 'block',
      atom: true,

      addAttributes() {
        return {
          text: { default: 'E = mc^2' }
        }
      },

      parseHTML() {
        return [{ tag: 'div[data-type="math-block"]' }]
      },

      renderHTML({ HTMLAttributes }) {
        return ['div', mergeAttributes(HTMLAttributes, { 'data-type': 'math-block' })]
      },

      addInputRules() {
        return [
          new InputRule({
            find: /^\$\$\s$/,
            type: this.type,
          }),
        ]
      },

      addNodeView() {
        return ({ node, getPos, editor }) => {
          const container = document.createElement('div');
          container.classList.add('math-block-container');

          const preview = document.createElement('div');
          preview.classList.add('math-preview');
          preview.title = 'Click to edit equation';

          const input = document.createElement('textarea');
          input.classList.add('math-input');
          input.value = node.attrs.text;
          input.placeholder = 'Type LaTeX equation (e.g. E = mc^2)';

          const renderMath = (text) => {
            preview.innerHTML = '';
            if (!text || text.trim() === '') {
              preview.textContent = 'Empty equation';
              preview.style.color = '#94a3b8';
              return;
            }
            try {
              katex.render(text, preview, {
                throwOnError: false,
                displayMode: true
              });
              preview.style.color = 'inherit';
            } catch (e) {
              preview.textContent = e.message;
              preview.style.color = '#ef4444';
            }
          };

          // Initial Render
          renderMath(node.attrs.text);

          // Interaction Logic
          let isEditing = false;

          const toggleEdit = (active) => {
            if (isEditing === active) return; // Debounce duplicate state changes
            isEditing = active;

            if (active) {
              container.classList.add('is-editing');
              // Small delay to ensure display:block applied before focus
              setTimeout(() => {
                input.focus();
              }, 10);
            } else {
              container.classList.remove('is-editing');
              // Save changes if dirty
              if (input.value !== node.attrs.text) {
                if (typeof getPos === 'function') {
                  const pos = getPos();
                  if (pos !== undefined && pos !== null) {
                    editor.chain().focus().command(({ tr }) => {
                      return tr.setNodeAttribute(pos, 'text', input.value);
                    }).run();
                  }
                }
              }
            }
          };

          preview.addEventListener('click', (e) => {
            e.preventDefault();
            toggleEdit(true);
          });

          input.addEventListener('input', (e) => {
            // Just update preview locally, don't trigger transaction yet
            renderMath(e.target.value);
          });

          input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              toggleEdit(false);
              editor.commands.focus(); // Return focus to editor
            }
          });

          // Handle blur - checks if focus moved outside the component
          input.addEventListener('blur', (e) => {
            // We use a timeout to allow clicks on other parts of UI to process first if needed
            // But simpler: just close.
            toggleEdit(false);
          });

          container.append(preview, input);

          return {
            dom: container,
            // Prevent ProtonMirror from re-rendering the node when we type in the textarea
            ignoreMutation: (mutation) => {
              // We handle our own mutations (textarea input)
              return true;
            },
            // Stop events from bubbling up to the editor to prevent unwanted side effects
            stopEvent: (event) => {
              // Allow default behavior for the textarea (keyboard interaction, etc.)
              if (event.target === input) {
                // For keydown, we want to stop propagation so Tiptap doesn't handle Enter/Backspace etc.
                // But for 'input', maybe not?
                // Generally returning true safely isolates the input.
                return true;
              }
              return false;
            },
            update: (updatedNode) => {
              if (updatedNode.type.name !== 'mathBlock') return false;
              // Sync local state if external update happened (e.g. Undo/Redo)
              if (updatedNode.attrs.text !== node.attrs.text) {
                node = updatedNode;
                input.value = node.attrs.text;
                renderMath(node.attrs.text);
              }
              return true;
            },
            selectNode: () => {
              container.classList.add('ProseMirror-selectednode');
            },
            deselectNode: () => {
              container.classList.remove('ProseMirror-selectednode');
              toggleEdit(false);
            }
          };
        }
      }
    });

    // 2. Callout
    const Callout = Node.create({
      name: 'callout',
      group: 'block',
      content: 'block+',
      draggable: true,
      addAttributes() {
        return {
          type: { default: 'info' }
        }
      },
      parseHTML() {
        return [{
          tag: 'div[data-type="callout"]',
          contentElement: '.callout-content' // Tell Tiptap to look for content HERE
        }]
      },
      renderHTML({ HTMLAttributes }) {
        let icon = 'üí°';
        if (HTMLAttributes.type === 'success') icon = '‚úÖ';
        if (HTMLAttributes.type === 'warning') icon = '‚ö†Ô∏è';
        if (HTMLAttributes.type === 'error') icon = '‚õî';

        return ['div', mergeAttributes(HTMLAttributes, { class: `callout callout-${HTMLAttributes.type}` }),
          ['span', { class: 'callout-icon', contenteditable: 'false' }, icon],
          ['div', { class: 'callout-content' }, 0]
        ]
      }
    });

    // 3. Page Break
    const PageBreak = Node.create({
      name: 'pageBreak',
      group: 'block',
      atom: true,
      parseHTML() { return [{ tag: 'div.page-break' }] },
      renderHTML({ HTMLAttributes }) {
        return ['div', mergeAttributes(HTMLAttributes, { class: 'page-break' })]
      }
    });


    // 5. Custom Code Block with Selector
    const CustomCodeBlock = CodeBlockLowlight.extend({
      addNodeView() {
        return ({ node, editor, getPos, extension }) => {
          const dom = document.createElement('div');
          dom.style.position = 'relative';
          dom.className = 'code-block-wrapper';

          const select = document.createElement('select');
          select.className = 'language-selector';
          select.contentEditable = 'false';

          // Common languages
          const langs = ['javascript', 'css', 'html', 'python', 'java', 'cpp', 'typescript', 'json', 'bash', 'go', 'rust'];

          langs.forEach(lang => {
            const option = document.createElement('option');
            option.value = lang;
            option.innerText = lang;
            if (lang === node.attrs.language) option.selected = true;
            select.appendChild(option);
          });

          select.addEventListener('change', (e) => {
            if (typeof getPos === 'function') {
              editor.commands.updateAttributes(getPos(), { language: e.target.value });
            }
          });

          const pre = document.createElement('pre');
          const code = document.createElement('code');

          pre.append(code);
          dom.append(select, pre);

          return {
            dom,
            contentDOM: code,
            update: (updatedNode) => {
              if (updatedNode.type.name !== this.name) return false;
              if (updatedNode.attrs.language !== node.attrs.language) {
                select.value = updatedNode.attrs.language;
              }
              return true;
            }
          };
        }
      }
    });

    // 6. MCQ Node
    const Mcq = Node.create({
      name: 'mcq',
      group: 'block',
      atom: true,
      draggable: true,
      selectable: true,

      addAttributes() {
        return {
          question: {
            default: '',
          },
          options: {
            default: [
              { id: '1', text: 'Option 1', isCorrect: false },
              { id: '2', text: 'Option 2', isCorrect: false },
            ],
          }
        }
      },

      parseHTML() {
        return [
          {
            tag: 'div[data-type="mcq"]',
          },
        ]
      },

      renderHTML({ HTMLAttributes }) {
        return ['div', mergeAttributes(HTMLAttributes, { 'data-type': 'mcq' })]
      },

      addNodeView() {
        return ({ node, getPos, editor }) => {
          // 1. Container
          const dom = document.createElement('div');
          dom.classList.add('mcq-node');
          dom.style.cssText = `
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            padding: 1.5rem;
            background: #fff;
            margin: 2rem 0;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transition: border-color 0.2s, box-shadow 0.2s;
            position: relative;
          `;

          // 2. Helper for Safe Updates
          const updateAttrs = (attrs) => {
            if (typeof getPos === 'function') {
              const pos = getPos();
              if (pos !== undefined && pos !== null) {
                editor.view.dispatch(
                  editor.state.tr.setNodeMarkup(pos, undefined, {
                    ...node.attrs,
                    ...attrs,
                  })
                );
              }
            }
          };

          // 3. Question Input
          const questionInput = document.createElement('input');
          questionInput.type = 'text';
          questionInput.placeholder = 'Enter your question...';
          questionInput.value = node.attrs.question;
          questionInput.style.cssText = `
            width: 100%;
            font-family: inherit;
            font-size: 1.125rem;
            font-weight: 600;
            color: #1e293b;
            border: none;
            border-bottom: 2px solid #e2e8f0;
            padding: 0.5rem 0;
            margin-bottom: 1.5rem;
            background: transparent;
            outline: none;
            transition: border-color 0.2s;
          `;

          questionInput.oninput = (e) => updateAttrs({ question: e.target.value });
          questionInput.onfocus = () => { questionInput.style.borderBottomColor = '#3b82f6'; };
          questionInput.onblur = () => { questionInput.style.borderBottomColor = '#e2e8f0'; };

          // 4. Options Container
          const optionsCtx = document.createElement('div');
          optionsCtx.style.cssText = 'display: flex; flex-direction: column; gap: 0.75rem;';

          // 5. Render Logic
          const renderOptions = () => {
            optionsCtx.innerHTML = '';
            node.attrs.options.forEach((option, index) => {
              const row = document.createElement('div');
              row.style.cssText = 'display: flex; align-items: center; gap: 0.75rem; width: 100%;';

              // Correct Toggle
              const checkbox = document.createElement('button');
              checkbox.style.cssText = `
                width: 24px;
                height: 24px;
                border-radius: 6px;
                border: 2px solid ${option.isCorrect ? '#22c55e' : '#cbd5e1'};
                background: ${option.isCorrect ? '#22c55e' : 'transparent'};
                color: white;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                flex-shrink: 0;
                transition: all 0.2s;
                padding: 0;
              `;
              if (option.isCorrect) {
                checkbox.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
              }

              checkbox.onmousedown = (e) => {
                e.preventDefault();
                // Single choice logic: Toggle clicked option, reset others to false
                const newOptions = node.attrs.options.map((opt, i) => ({
                  ...opt,
                  isCorrect: i === index ? !opt.isCorrect : false
                }));
                updateAttrs({ options: newOptions });
              };

              // Text Input
              const input = document.createElement('input');
              input.type = 'text';
              input.value = option.text;
              input.placeholder = `Option ${index + 1}`;
              input.style.cssText = `
                flex: 1;
                padding: 0.5rem 0.75rem;
                border: 1px solid ${option.isCorrect ? '#86efac' : '#e2e8f0'};
                border-radius: 0.5rem;
                font-size: 0.95rem;
                color: #334155;
                outline: none;
                transition: all 0.2s;
                background: ${option.isCorrect ? '#f0fdf4' : 'transparent'};
              `;

              input.oninput = (e) => {
                const newOptions = [...node.attrs.options];
                newOptions[index] = { ...newOptions[index], text: e.target.value };
                updateAttrs({ options: newOptions });
              };

              input.onfocus = () => { if (!option.isCorrect) input.style.borderColor = '#3b82f6'; };
              input.onblur = () => { if (!option.isCorrect) input.style.borderColor = '#e2e8f0'; };

              // Delete Button
              const del = document.createElement('button');
              del.innerHTML = '√ó';
              del.style.cssText = `
                 width: 24px;
                 height: 24px;
                 display: flex;
                 align-items: center;
                 justify-content: center;
                 border: none;
                 background: transparent;
                 color: #94a3b8;
                 cursor: pointer;
                 font-size: 20px;
                 border-radius: 4px;
                 transition: color 0.2s;
                 line-height: 1;
                 padding: 0;
              `;
              del.onmouseenter = () => del.style.color = '#ef4444';
              del.onmouseleave = () => del.style.color = '#94a3b8';
              del.onmousedown = (e) => {
                e.preventDefault();
                const newOptions = node.attrs.options.filter((_, i) => i !== index);
                updateAttrs({ options: newOptions });
              };

              row.append(checkbox, input, del);
              optionsCtx.appendChild(row);
            });
          };

          renderOptions();

          // 6. Add Button
          const addBtn = document.createElement('button');
          addBtn.innerHTML = '+ Add Option';
          addBtn.style.cssText = `
            margin-top: 1rem;
            padding: 0.5rem 1rem;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            color: #475569;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
          `;
          addBtn.onmouseenter = () => { addBtn.style.background = '#f1f5f9'; addBtn.style.color = '#1e293b'; };
          addBtn.onmouseleave = () => { addBtn.style.background = '#f8fafc'; addBtn.style.color = '#475569'; };
          addBtn.onmousedown = (e) => {
            e.preventDefault();
            const newId = Math.random().toString(36).slice(2, 9);
            const newOptions = [...node.attrs.options, { id: newId, text: '', isCorrect: false }];
            updateAttrs({ options: newOptions });
          };

          dom.append(questionInput, optionsCtx, addBtn);

          return {
            dom,
            ignoreMutation: (mutation) => {
              // Internal updates (handled by listeners) should be ignored by ProseMirror
              if (dom.contains(mutation.target)) return true;
              return false;
            },
            stopEvent: (event) => {
              // Allow input interaction, block everything else to prevent selection weirdness
              if (event.target.tagName === 'INPUT') return true;
              if (event.type === 'dragstart' && !dom.contains(event.target)) return false;
              return false;
            },
            update: (updatedNode) => {
              if (updatedNode.type.name !== 'mcq') return false;

              // Question Sync
              if (updatedNode.attrs.question !== node.attrs.question) {
                questionInput.value = updatedNode.attrs.question;
              }

              // Options Sync
              if (JSON.stringify(updatedNode.attrs.options) !== JSON.stringify(node.attrs.options)) {
                node = updatedNode;

                // Check if only visual updates are needed to preserve focus
                const inputs = optionsCtx.querySelectorAll('input[type="text"]');
                let domMatches = true;

                if (inputs.length !== node.attrs.options.length) domMatches = false;
                else {
                  node.attrs.options.forEach((opt, i) => {
                    if (inputs[i].value !== opt.text) domMatches = false;
                  });
                }

                if (!domMatches) {
                  renderOptions();
                } else {
                  // Update visuals only
                  Array.from(optionsCtx.children).forEach((row, i) => {
                    const opt = node.attrs.options[i];
                    if (opt && row) {
                      const cb = row.children[0];
                      const inp = row.children[1];

                      cb.style.borderColor = opt.isCorrect ? '#22c55e' : '#cbd5e1';
                      cb.style.background = opt.isCorrect ? '#22c55e' : 'transparent';
                      cb.innerHTML = opt.isCorrect ? `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>` : '';

                      inp.style.borderColor = opt.isCorrect ? '#86efac' : (document.activeElement === inp ? '#3b82f6' : '#e2e8f0');
                      inp.style.background = opt.isCorrect ? '#f0fdf4' : 'transparent';
                    }
                  });
                }
              } else {
                node = updatedNode;
              }
              return true;
            },
            selectNode: () => {
              dom.style.borderColor = '#3b82f6';
              dom.style.boxShadow = '0 0 0 3px rgba(59, 130, 246, 0.1)';
            },
            deselectNode: () => {
              dom.style.borderColor = '#e2e8f0';
              dom.style.boxShadow = '0 4px 6px -1px rgba(0, 0, 0, 0.1)';
            }
          };
        }
      }
    });

    /* --- Slash Menu Configuration --- */
    const slashGroups = [
      {
        title: 'Text',
        items: [
          { title: 'Paragraph', icon: 'T', action: editor => editor.chain().focus().setParagraph().run() },
          { title: 'Heading 1', icon: 'H1', action: editor => editor.chain().focus().toggleHeading({ level: 1 }).run() },
          { title: 'Heading 2', icon: 'H2', action: editor => editor.chain().focus().toggleHeading({ level: 2 }).run() },
          { title: 'Heading 3', icon: 'H3', action: editor => editor.chain().focus().toggleHeading({ level: 3 }).run() },
          { title: 'Bullet List', icon: '‚Ä¢', action: editor => editor.chain().focus().toggleBulletList().run() },
          { title: 'Numbered List', icon: '1.', action: editor => editor.chain().focus().toggleOrderedList().run() },
        ]
      },
      {
        title: 'Media',
        items: [
          {
            title: 'Image',
            description: 'Upload an image',
            icon: 'üñºÔ∏è',
            action: async (editor) => {
              const file = await triggerFileUpload('image/*');
              if (file) editor.chain().focus().setImage({ src: file.src }).run();
            }
          },
          {
            title: 'Video',
            description: 'Upload a video',
            icon: 'üìπ',
            action: async (editor) => {
              const file = await triggerFileUpload('video/*');
              if (file) editor.chain().focus().insertContent({ type: 'video', attrs: { src: file.src } }).run();
            }
          },
          {
            title: 'File',
            description: 'Upload a file attachment',
            icon: 'üìé',
            action: async (editor) => {
              const file = await triggerFileUpload('*/*');
              if (file) editor.chain().focus().insertContent({ type: 'fileAttachment', attrs: { src: file.src, name: file.name, size: file.size } }).run();
            }
          }
        ]
      },
      {
        title: 'AI Actions',
        items: [
          { title: 'Improve Writing', icon: '‚ú®', action: editor => handleAIRequest('improve') },
          { title: 'Summarize', icon: 'üìù', action: editor => handleAIRequest('summarize') },
          { title: 'Explain', icon: 'ü§î', action: editor => handleAIRequest('explain') },
          { title: 'Continue Writing', icon: '‚û°Ô∏è', action: editor => handleAIRequest('continue') },
        ]
      },
      {
        title: 'Blocks',
        items: [
          { title: 'Mcq', description: 'Insert an MCQ block', icon: 'üìù', action: editor => editor.chain().focus().insertContent({ type: 'mcq' }).run() },
          { title: 'Table', icon: '‚ñ¶', action: editor => editor.chain().focus().insertTable({ rows: 3, cols: 3, withHeaderRow: true }).run() },
          { title: 'Code Block', icon: '{ }', action: editor => editor.chain().focus().toggleCodeBlock().run() },
          { title: 'Math Equation', description: 'Insert a block equation (LaTeX)', icon: '‚àë', action: editor => editor.chain().focus().insertContent({ type: 'mathBlock' }).run() },
          { title: 'Callout', icon: 'üí°', action: editor => editor.chain().focus().insertContent({ type: 'callout', content: [{ type: 'paragraph' }] }).run() },
          { title: 'Page Break', icon: '‚úÇÔ∏è', action: editor => editor.chain().focus().insertContent({ type: 'pageBreak' }).run() }
        ]
      },
      {
        title: 'Utilities',
        items: [
          { title: 'Date', icon: 'üìÖ', action: editor => editor.chain().focus().insertContent(new Date().toLocaleDateString()).run() },
          { title: 'Time', icon: '‚è∞', action: editor => editor.chain().focus().insertContent(new Date().toLocaleTimeString()).run() },
          { title: 'Date & Time', icon: 'üìÜ', action: editor => editor.chain().focus().insertContent(new Date().toLocaleString()).run() },
          { title: 'Task List', icon: '‚òëÔ∏è', action: editor => editor.chain().focus().toggleTaskList().run() },
          { title: 'Divider', icon: '‚Äî', action: editor => editor.chain().focus().setHorizontalRule().run() },
        ]
      }
    ];

    const SlashCommand = Extension.create({
      name: 'slashCommand',
      addProseMirrorPlugins() {
        return [
          Suggestion({
            editor: this.editor,
            char: '/',
            startOfLine: false,
            items: ({ query }) => {
              return slashGroups.map(group => ({
                title: group.title,
                items: group.items.filter(item => item.title.toLowerCase().includes(query.toLowerCase()))
              })).filter(group => group.items.length > 0);
            },
            render: () => {
              let popup;
              let selectedIndex = 0;
              let suggestionProps;
              let domNodes = []; // Store references to item elements

              const renderList = () => {
                if (!popup) return;
                popup.innerHTML = '';
                domNodes = [];

                if (suggestionProps.items.length === 0) {
                  popup.style.display = 'none';
                  return;
                }
                popup.style.display = 'block';

                suggestionProps.items.forEach(group => {
                  const groupTitle = document.createElement('div');
                  groupTitle.className = 'slash-group-title';
                  groupTitle.textContent = group.title;
                  popup.appendChild(groupTitle);

                  group.items.forEach(item => {
                    const el = document.createElement('div');
                    el.className = 'slash-item';
                    el.innerHTML = `
                      <div class="slash-item-icon">${item.icon}</div>
                      <div class="slash-item-content">
                        <div class="slash-item-title">${item.title}</div>
                        ${item.description ? `<div class="slash-item-desc">${item.description}</div>` : ''}
                      </div>
                    `;

                    el.addEventListener('mousedown', (e) => {
                      e.preventDefault();
                      e.stopPropagation();
                      execute(item);
                    });

                    popup.appendChild(el);
                    domNodes.push({ el, item });
                  });
                });
              };

              const updateSelection = (scroll = false) => {
                domNodes.forEach(({ el }, index) => {
                  if (index === selectedIndex) {
                    el.classList.add('is-selected');
                    if (scroll) {
                      el.scrollIntoView({ block: 'nearest', inline: 'nearest' });
                    }
                  } else {
                    el.classList.remove('is-selected');
                  }
                });
              };

              const execute = (item) => {
                if (suggestionProps) {
                  const { editor, range } = suggestionProps;
                  editor.chain().focus().deleteRange(range).run();
                  item.action(editor);
                }
              };

              const updatePosition = () => {
                const rect = suggestionProps.clientRect();
                if (rect) {
                  popup.style.position = 'absolute';
                  popup.style.top = (rect.bottom + window.scrollY + 10) + 'px';
                  popup.style.left = rect.left + 'px';
                }
              };

              return {
                onStart: props => {
                  suggestionProps = props;
                  popup = document.createElement('div');
                  popup.className = 'slash-popup';
                  document.body.appendChild(popup);
                  selectedIndex = 0;
                  renderList();
                  updateSelection(false); // No scroll on start
                  updatePosition();
                },
                onUpdate(props) {
                  suggestionProps = props;
                  selectedIndex = 0;
                  renderList();
                  updateSelection(false); // No scroll on update
                  updatePosition();
                },
                onKeyDown(props) {
                  if (props.event.key === 'ArrowUp') {
                    selectedIndex = (selectedIndex + domNodes.length - 1) % domNodes.length;
                    updateSelection(true); // Scroll on key nav
                    return true;
                  }
                  if (props.event.key === 'ArrowDown') {
                    selectedIndex = (selectedIndex + 1) % domNodes.length;
                    updateSelection(true); // Scroll on key nav
                    return true;
                  }
                  if (props.event.key === 'Enter') {
                    if (domNodes[selectedIndex]) {
                      execute(domNodes[selectedIndex].item);
                    }
                    return true;
                  }
                  return false;
                },
                onExit() {
                  if (popup) popup.remove();
                  popup = null;
                  domNodes = [];
                }
              };
            }
          })
        ];
      }
    });

    /* --- Editor Initialization --- */
    const editor = new Editor({
      element: document.querySelector('#editor'),
      extensions: [
        Document,
        Paragraph,
        Text,
        Blockquote,
        BulletList,
        OrderedList,
        ListItem,
        HardBreak,
        HorizontalRule,
        Heading.configure({ levels: [1, 2, 3] }),
        Bold,
        Code,
        Italic,
        Strike,
        Dropcursor.configure({ color: '#3b82f6', width: 2 }),
        Gapcursor,
        History,
        Placeholder.configure({
          placeholder: 'Type / for commands...',
        }),
        TaskList,
        TaskItem.configure({ nested: true }),
        Link.configure({ openOnClick: false }),
        CustomImage.configure({
          allowBase64: true,
          inline: true,
        }),
        Youtube.configure({ controls: false }),
        Table.configure({ resizable: true }),
        TableRow, TableHeader, TableCell,
        // Replace CodeBlockLowlight with CustomCodeBlock
        CustomCodeBlock.configure({
          lowlight,
          defaultLanguage: 'javascript',
        }),
        MathBlock,
        Callout,
        PageBreak,
        Mcq,
        // DateTime,
        Video,
        FileAttachment,
        SlashCommand,
        BubbleMenu.configure({
          pluginKey: 'tableBubbleMenu',
          element: document.querySelector('#table-bubble-menu'),
          shouldShow: ({ editor }) => editor.isActive('table')
        }),
        BubbleMenu.configure({
          pluginKey: 'aiBubbleMenu',
          element: document.querySelector('#ai-bubble-menu'),
          shouldShow: ({ editor, from, to }) => {
            // Show only when text is selected and NOT in a table (optional constraint)
            return !editor.state.selection.empty && !editor.isActive('table');
          }
        })
      ],
      content: `
          <h1>Premium Editor</h1>
          <p>This is a polished TipTap editor with <strong>Code highlighting</strong>, <strong>Math</strong> support, and better UI.</p>
          <pre><code class="language-javascript">console.log('Hello World');</code></pre>
          <div data-type="callout" class="callout callout-info"><span class="callout-icon">üí°</span><div class="callout-content"><p>Try typing <code>/</code> to see the grouped menu.</p></div></div>
        `,
      editorProps: {
        attributes: {
          class: 'prose prose-sm sm:prose lg:prose-lg xl:prose-2xl focus:outline-none',
        },
      },
      onUpdate({ editor }) {
        document.getElementById('debug-json').textContent = JSON.stringify(editor.getJSON(), null, 2);
      }
    });

    // Initial Render
    document.getElementById('debug-json').textContent = JSON.stringify(editor.getJSON(), null, 2);

    // Populate Table Bubble Menu
    const tableMenuContainer = document.querySelector('#table-bubble-menu');
    if (tableMenuContainer) tableMenuContainer.className = 'bubble-menu hidden';

    // Helper to create buttons
    const createBtn = (icon, action, title, isDestructive = false) => {
      const btn = document.createElement('button');
      btn.className = `bubble-btn ${isDestructive ? 'text-red-500 hover:text-red-700 hover:bg-red-50' : ''}`;
      btn.innerHTML = icon;
      btn.title = title;
      btn.onclick = () => editor.chain().focus()[action]().run();
      return btn;
    };

    if (tableMenuContainer) {
      tableMenuContainer.append(
        createBtn('‚Üê', 'addColumnBefore', 'Add Col Before'),
        createBtn('‚Üí', 'addColumnAfter', 'Add Col After'),
        createBtn('‚Üë', 'addRowBefore', 'Add Row Before'),
        createBtn('‚Üì', 'addRowAfter', 'Add Row After'),
        createBtn('üóëÔ∏è', 'deleteTable', 'Delete Table', true)
      );
    }

    /* --- AI Integration --- */
    const aiMenu = document.getElementById('ai-bubble-menu');
    const aiLoader = document.getElementById('ai-loader');
    const aiBtns = document.querySelectorAll('.ai-btn');

    const handleAIRequest = async (action) => {
      const { state, view } = editor;
      let { from, to } = state.selection;
      let selectedText = state.doc.textBetween(from, to, ' ');
      let range = { from, to };

      // Fallback: If no selection, use the text of the current block or previous block
      if (!selectedText.trim()) {
        const resolvedPos = state.doc.resolve(from);
        const parent = resolvedPos.parent;

        // If inside a text block, use its content
        if (parent.isTextblock && parent.textContent.trim()) {
          selectedText = parent.textContent;
          range = {
            from: resolvedPos.start(),
            to: resolvedPos.end()
          };
        } else {
          // Try previous block if current is empty (e.g. typing '/' on new line)
          // This is tricky, let's just stick to "Text before cursor" for 'continue'
          if (action === 'continue') {
            // Get last 1000 chars
            selectedText = state.doc.textBetween(Math.max(0, from - 1000), from, ' ');
            range = { from, to }; // Insert at cursor
          }
        }
      }

      if (!selectedText.trim()) {
        alert('Please select text or place cursor near text to use AI.');
        return;
      }

      // Re-query elements to ensure safety
      // Use global loader for reliability
      const globalLoader = document.getElementById('loading-overlay');
      const loaderText = globalLoader?.querySelector('p');
      const aiLoader = document.getElementById('ai-loader'); // Optional bubble loader

      if (globalLoader) {
        if (loaderText) loaderText.textContent = 'AI Processing...';
        globalLoader.classList.add('active');
      }
      if (aiLoader) aiLoader.classList.remove('hidden');

      // Disable buttons if they exist
      const aiBtns = document.querySelectorAll('.ai-btn');
      aiBtns.forEach(btn => btn.disabled = true);

      let prompt = '';
      switch (action) {
        case 'improve': prompt = `Rewrite this text to be more professional, clear, and concise:\n\n"${selectedText}"`; break;
        case 'summarize': prompt = `Summarize this text in one sentence:\n\n"${selectedText}"`; break;
        case 'explain': prompt = `Explain this text simply:\n\n"${selectedText}"`; break;
        case 'continue': prompt = `Continue writing naturally from this text (do not repeat it):\n\n"${selectedText}"`; break;
      }

      try {
        const response = await fetch(GEMINI_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            contents: [{
              role: "user",
              parts: [{ text: prompt }]
            }]
          })
        });

        const data = await response.json();

        if (data.error) {
          console.error('Gemini Error:', data.error);
          alert('AI Error: ' + data.error.message);
          return;
        }

        const aiText = data.candidates?.[0]?.content?.parts?.[0]?.text;

        if (aiText) {
          const chain = editor.chain().focus();

          if (action === 'continue') {
            chain.insertContentAt(range.to, " " + aiText); // Append
          } else {
            // chain.replaceWith is not a Tiptap command. Use deleteRange + insertContent
            chain.deleteRange(range).insertContentAt(range.from, aiText);
          }

          chain.run();
        }

      } catch (error) {
        console.error('Network Error:', error);
        alert('Failed to connect to AI service.');
      } finally {
        // Reset UI
        if (globalLoader) {
          globalLoader.classList.remove('active');
          if (loaderText) loaderText.textContent = 'Uploading...'; // Reset default text
        }
        if (aiLoader) aiLoader.classList.add('hidden');
        aiBtns.forEach(btn => btn.disabled = false);
      }
    };

    // Attach Listeners
    aiBtns.forEach(btn => {
      btn.onclick = (e) => {
        e.preventDefault(); // Prevent losing focus
        handleAIRequest(btn.dataset.action);
      };
    });

  </script>
</body>

</html>